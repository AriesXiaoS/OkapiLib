<!doctype html>
<html>
<head>
	<meta name="generator" content="Hugo 0.26" />
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>OkapiLib Docs</title>
    <link href='/OkapiDocs/slate/stylesheets/monokai.css' rel="stylesheet" media="screen" />
<link href='/OkapiDocs/slate/stylesheets/screen.css' rel="stylesheet" media="screen" />
<link href='/OkapiDocs/slate/stylesheets/print.css' rel="stylesheet" media="print" />

    
<script src='/OkapiDocs/slate/javascripts/all.js'></script>

    
</head>
<body class="index" data-languages="">
    <a href="#" id="nav-button">
        <span>
        NAV
        <img src='/OkapiDocs/slate/images/navbar.png'/>
      </span>
    </a>
    <div class="tocify-wrapper">
        
         <img src='/OkapiDocs/images/logo.png' />
         
        
        <div class="search">
            <input type="text" class="search" id="input-search" placeholder='Search'>
        </div>
        <ul class="search-results"></ul>
        
        <div id="toc">
        </div>
         
        
        
    </div>
    <div class="page-wrapper">
        <div class="dark-box"></div>
        <div class="content">
            
    
        

<h1 id="okapi-documentation">Okapi Documentation</h1>

<h2 id="primary-objective">Primary Objective</h2>

<p>Welcome to Okapi! This library is designed to make modeling and programming complex robot behavior easy, efficient, and maintainable. This library is targeted at PROS users looking to take their competition robot to the next level, whether that means starting to use motion profiles instead of PID or designing an autonomous robot from the ground up. Okapi also comes with an optional cross-platform client that lets you interact with your robot in real time as a graphical interface to Okapi&rsquo;s modules.</p>

<p>This is the documentation website for both Okapi&rsquo;s PROS library and optional client.</p>

<h2 id="target-audience">Target Audience</h2>

<p>Okapi is targeted at users of PROS that are familiar with C++ programming. If you are not comfortable with PROS, there are tutorials on the <a href="https://pros.cs.purdue.edu">PROS website</a>, and those still learning C++ should look towards <a href="https://www.tutorialspoint.com/cplusplus/">tutorialspoint</a> and <a href="http://www.cs.wustl.edu/~schmidt/C++/">Washington University</a>.</p>

    
        

<h1 id="api">API</h1>

<p>This section is meant to be a quick reference for Okapi&rsquo;s entire API, including methods the user may not normally interact with. This reference is broken into sections, covering one class per section. Subclasses are placed below the base class, but in different sections. If a class is marked (abstract) then it contains one or more pure virtual functions, and cannot be instantiated (it is designed only to be an interface).</p>

<aside class="notice">
Remember that derived classes inherit the interface of their base class; therefore, derived classes will not have their base class' functions documented (you can safely assume that all functions from the base class are implemented).
</aside>

    
        

<h1 id="chassiscontroller-abstract">ChassisController (abstract)</h1>

<p>The <code>ChassisController</code> class an interface for controlling a robot&rsquo;s chassis: it provides methods that build upon the basic methods <code>ChassisModel</code> has for more accurate control.</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">ChassisController</span><span class="p">(</span><span class="k">const</span> <span class="n">ChassisModelParams</span><span class="o">&amp;</span> <span class="n">imodelParams</span><span class="p">)</span>
<span class="n">ChassisController</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ChassisModel</span><span class="o">&gt;</span> <span class="n">imodel</span><span class="p">)</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imodelParams</td>
<td><code>ChassisModelParams</code> (used to make a new <code>ChassisModel</code>)</td>
</tr>

<tr>
<td>imodel</td>
<td>An existing <code>ChassisModel</code></td>
</tr>
</tbody>
</table>

<h2 id="drivestraight">driveStraight</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">driveStraight</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">itarget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>

<p>Drive the robot straight for a distance of <code>itarget</code> in the units of <code>itarget</code>.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>itarget</td>
<td>Distance for the robot to travel</td>
</tr>
</tbody>
</table>

<h2 id="pointturn">pointTurn</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">pointTurn</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">idegTarget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>

<p>Turn the robot in place for an angle of <code>idegTarget</code>. The units of the angle travel is most often the difference in encoder ticks between the two sides of the chassis.</p>

    
        

<h1 id="chassiscontrollerpid">ChassisControllerPid</h1>

<p>The <code>ChassisControllerPid</code> class inherits from <code>ChassisController</code> and implements its interface using PID control.</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">ChassisControllerPid</span><span class="p">(</span><span class="k">const</span> <span class="n">ChassisModelParams</span><span class="o">&amp;</span> <span class="n">imodelParams</span><span class="p">,</span> <span class="n">PidParams</span> <span class="n">idistanceParams</span><span class="p">,</span> <span class="n">PidParams</span> <span class="n">iangleParams</span><span class="p">)</span>
<span class="n">ChassisControllerPid</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ChassisModel</span><span class="o">&gt;</span> <span class="n">imodel</span><span class="p">,</span> <span class="n">PidParams</span> <span class="n">idistanceParams</span><span class="p">,</span> <span class="n">PidParams</span> <span class="n">iangleParams</span><span class="p">)</span>

<span class="c1">//Make a new ChassisControllerPid using a skid steer model with two motors per side</span>
<span class="n">ChassisControllerPid</span> <span class="n">foo</span><span class="p">(</span>
  <span class="n">SkidSteerModelParams</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="c1">//The four motor ports</span>
                          <span class="n">encoderInit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">false</span><span class="p">),</span> <span class="c1">//Left encoder</span>
                          <span class="n">encoderInit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">true</span><span class="p">)),</span> <span class="c1">//Right encoder</span>
  <span class="n">PidParams</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">),</span>    <span class="c1">//Distance PID controller</span>
  <span class="n">PidParams</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">));</span> <span class="c1">//Angle PID controller</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imodelParams</td>
<td><code>ChassisModelParams</code> (used to make a new <code>ChassisModel</code>)</td>
</tr>

<tr>
<td>imodel</td>
<td>An existing <code>ChassisModel</code></td>
</tr>

<tr>
<td>idistanceParams</td>
<td><code>PidParams</code> for the distance PID controller</td>
</tr>

<tr>
<td>iangleParams</td>
<td><code>PidParams</code> for the angle PID controller</td>
</tr>
</tbody>
</table>

<aside class="notice">
Most users should not call this constructor with a std::shared_ptr&lt;ChassisModel&gt;. Instead, pass a ChassisModelParams and Okapi will figure out what to do.
</aside>

<h1 id="chassiscontrollermp">ChassisControllerMP</h1>

<p>The <code>ChassisControllerMP</code> class inherits from <code>ChassisController</code> and implements its interface using motion profiling.</p>

<h2 id="constructor-1">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">ChassisControllerMP</span><span class="p">(</span><span class="k">const</span> <span class="n">ChassisModelParams</span><span class="o">&amp;</span> <span class="n">imodelParams</span><span class="p">,</span> <span class="n">MPGenParams</span> <span class="n">igenParams</span><span class="p">,</span> <span class="n">MPConsumerParams</span> <span class="n">icParams</span><span class="p">)</span>
<span class="n">ChassisControllerMP</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ChassisModel</span><span class="o">&gt;</span> <span class="n">imodel</span><span class="p">,</span> <span class="n">MPGenParams</span> <span class="n">igenParams</span><span class="p">,</span> <span class="n">MPConsumerParams</span> <span class="n">icParams</span><span class="p">)</span>

<span class="c1">//Make a new ChassisControllerMP using a skid steer model with two motors per side</span>
<span class="n">ChassisControllerMP</span> <span class="n">foo</span><span class="p">(</span>
  <span class="n">SkidSteerModelParams</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="c1">//The four motor ports</span>
                          <span class="n">encoderInit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">false</span><span class="p">),</span> <span class="c1">//Left encoder</span>
                          <span class="n">encoderInit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">true</span><span class="p">)),</span> <span class="c1">//Right encoder</span>
  <span class="n">MPGenParams</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span>       <span class="c1">//MPGenerator params; max &amp; min accel: 1, max vel: 15, target pos: 1000</span>
  <span class="n">MPConsumerParams</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">));</span> <span class="c1">//MPConsumer params; kV: 6, kA: 1.2, kP: 0.5</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imodelParams</td>
<td><code>ChassisModelParams</code> (used to make a new <code>ChassisModel</code>)</td>
</tr>

<tr>
<td>imodel</td>
<td>An existing <code>ChassisModel</code></td>
</tr>

<tr>
<td>igenParams</td>
<td><code>MPGenParams</code> (used to make a new <code>MPGenerator</code>)</td>
</tr>

<tr>
<td>icParams</td>
<td><code>MPConsumerParams</code> (used to make a new <code>MPConsumer</code>)</td>
</tr>
</tbody>
</table>

<aside class="notice">
Most users should not call this constructor with a std::shared_ptr&lt;ChassisModel&gt;. Instead, pass a ChassisModelParams and Okapi will figure out what to do.
</aside>

    
        

<h1 id="odomchassiscontroller-abstract">OdomChassisController (abstract)</h1>

<p>The <code>OdomChassisController</code> class inherits from <code>ChassisController</code>. It extends the <code>ChassisController</code> interface to add odometry-based functionality.</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">OdomChassisController</span><span class="p">(</span><span class="n">OdomParams</span> <span class="n">iparams</span><span class="p">)</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iparams</td>
<td><code>OdomParams</code> (used to make a new <code>Odometry</code>)</td>
</tr>
</tbody>
</table>

<aside class="notice">
This class creates a new task inside its constructor and references a static class (Odometry). Be careful and remember to only make one.
</aside>

<h2 id="drivetopoint">driveToPoint</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">driveToPoint</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">ix</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">iy</span><span class="p">,</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">ibackwards</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ioffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ix</td>
<td>X coordinate of destination</td>
</tr>

<tr>
<td>iy</td>
<td>Y coordinate of destination</td>
</tr>

<tr>
<td>ibackwards</td>
<td>Whether to drive to the destination backwards (default false)</td>
</tr>

<tr>
<td>ioffset</td>
<td>How far back from the destination to stop (default 0)</td>
</tr>
</tbody>
</table>

<p>Drive to the point (<code>ix</code>, <code>iy</code>) in the field frame. If required, the robot will first turn to face the destination point.</p>

<h2 id="turntoangle">turnToAngle</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">turnToAngle</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">iangle</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iangle</td>
<td>Angle to face</td>
</tr>
</tbody>
</table>

<p>Turn to the angle <code>iangle</code> in the field frame.</p>

    
        

<h1 id="odomchassiscontrollerpid">OdomChassisControllerPid</h1>

<p>The <code>OdomChassisControllerPid</code> class inherits from <code>OdomChassisController</code> and from <code>ChassisControllerPid</code>. It implements the <code>OdomChassisController</code> interface using PID control.</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">OdomChassisControllerPid</span><span class="p">(</span><span class="n">OdomParams</span> <span class="n">params</span><span class="p">,</span> <span class="n">PidParams</span> <span class="n">idistanceParams</span><span class="p">,</span> <span class="n">PidParams</span> <span class="n">iangleParams</span><span class="p">)</span>

<span class="c1">//Make a new OdomChassisControllerPid using a skid steer model with two motors per side</span>
<span class="n">OdomChassisControllerPid</span> <span class="n">foo</span><span class="p">(</span>
  <span class="n">OdomParams</span><span class="p">(</span>
    <span class="n">SkidSteerModelParams</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span> <span class="c1">//The four motor ports</span>
                            <span class="n">encoderInit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="nb">false</span><span class="p">),</span> <span class="c1">//Left encoder</span>
                            <span class="n">encoderInit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="nb">true</span><span class="p">)),</span> <span class="c1">//Right encoder</span>
    <span class="mf">1.345</span><span class="p">,</span>     <span class="c1">//Distance scale (encoder ticks to mm)</span>
    <span class="mf">12.88361</span><span class="p">),</span> <span class="c1">//Turn scale (encoder ticks to deg)</span>
  <span class="n">PidParams</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>  <span class="c1">//Distance PID controller</span>
  <span class="n">PidParams</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span> <span class="c1">//Angle PID controller</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>params</td>
<td><code>OdomParams</code> (used to make a new <code>Odometry</code>)</td>
</tr>

<tr>
<td>idistanceParams</td>
<td><code>PidParams</code> for the distance PID controller</td>
</tr>

<tr>
<td>iangleParams</td>
<td><code>PidParams</code> for the angle PID controller</td>
</tr>
</tbody>
</table>

<h1 id="odomchassiscontrollermp">OdomChassisControllerMP</h1>

<p>The <code>OdomChassisControllerMP</code> class inherits from <code>OdomChassisController</code> and from <code>ChassisControllerMP</code>. It implements the <code>OdomChassisController</code> interface using motion profiling.</p>

<h2 id="constructor-1">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">OdomChassisControllerMP</span><span class="p">(</span><span class="n">OdomParams</span> <span class="n">params</span><span class="p">,</span> <span class="n">MPGenParams</span> <span class="n">iparams</span><span class="p">,</span> <span class="n">MPConsumerParams</span> <span class="n">icParams</span><span class="p">)</span>

<span class="c1">//Make a new ChassisControllerMP using a skid steer model with two motors per side</span>
<span class="n">OdomChassisControllerMP</span> <span class="n">foo</span><span class="p">(</span>
  <span class="n">OdomParams</span><span class="p">(</span>
    <span class="n">SkidSteerModelParams</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span> <span class="c1">//The four motor ports</span>
                            <span class="n">encoderInit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="nb">false</span><span class="p">),</span> <span class="c1">//Left encoder</span>
                            <span class="n">encoderInit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="nb">true</span><span class="p">)),</span> <span class="c1">//Right encoder</span>
    <span class="mf">1.345</span><span class="p">,</span>     <span class="c1">//Distance scale (encoder ticks to mm)</span>
    <span class="mf">12.88361</span><span class="p">),</span> <span class="c1">//Turn scale (encoder ticks to deg)</span>
  <span class="n">MPGenParams</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span>       <span class="c1">//MPGenerator params; max &amp; min accel: 1, max vel: 15, target pos: 1000</span>
  <span class="n">MPConsumerParams</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">));</span> <span class="c1">//MPConsumer params; kV: 6, kA: 1.2, kP: 0.5</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>params</td>
<td><code>OdomParams</code> (used to make a new <code>Odometry</code>)</td>
</tr>

<tr>
<td>igenParams</td>
<td><code>MPGenParams</code> (used to make a new <code>MPGenerator</code>)</td>
</tr>

<tr>
<td>icParams</td>
<td><code>MPConsumerParams</code> (used to make a new <code>MPConsumer</code>)</td>
</tr>
</tbody>
</table>

    
        

<h1 id="chassismodel-abstract">ChassisModel (abstract)</h1>

<p>The <code>ChassisModel</code> class is an interface to a robot&rsquo;s chassis: it provides methods to control the chassis and to read from standard sensors placed on most chassis (i.e., quadrature encoders).</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">ChassisModel</span><span class="p">()</span>
</code></pre></div>

<p>The constructor does not take any parameters.</p>

<h2 id="driveforward">driveForward</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">driveForward</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">power</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>

<p>Drives the chassis forwards by setting all motors to the input power. A positive value for <code>power</code> should cause all chassis wheels to move the robot forward in a straight line.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>power</td>
<td>The raw motor power sent directly to the chassis&rsquo; motors</td>
</tr>
</tbody>
</table>

<h2 id="turnclockwise">turnClockwise</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">turnClockwise</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">power</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>

<p>Turns the robot clockwise by setting the left side motors to the input power and the right side motors to the negative of the input power. A positive value for <code>power</code> should cause all chassis wheels to turn the robot clockwise on a point.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>power</td>
<td>The raw motor power sent directly to the chassis&rsquo; motors</td>
</tr>
</tbody>
</table>

<h2 id="drivevector">driveVector</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">driveVector</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">distPower</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">anglePower</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">driveVector</span><span class="p">(</span><span class="mi">127</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">//Same as driveForward(127)</span>
<span class="n">driveVector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">127</span><span class="p">)</span> <span class="c1">//Same as turnClockwise(127)</span>

<span class="c1">//Make a moderate swing turn clockwise</span>
<span class="c1">//left motors get 110 power, right motors get 70 power</span>
<span class="n">driveVector</span><span class="p">(</span><span class="mi">90</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
</code></pre></div>

<p>Drive the chassis along a curved path. Calling <code>driveVector(127, 0)</code> should be equivalent to calling <code>driveForward(127)</code>; calling <code>driveVector(0, 127)</code> should be equivalent to calling <code>turnClockwise(127)</code>. A mix between the two will cause the robot to make a swing turn.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>distPower</td>
<td>The motor power making up the &ldquo;straight&rdquo; component of the final motor power</td>
</tr>

<tr>
<td>anglePower</td>
<td>The motor power making up the &ldquo;turn&rdquo; component of the final motor power</td>
</tr>
</tbody>
</table>

<h2 id="getencodervals">getEncoderVals</h2>

<p>Reads the encoders given to the chassis model at construction time and returns them in the format <code>{left encoder value, right encoder value}</code>. Return type is a <code>std::valarray</code> because it features operator overrides for common math operations making encoder math easy.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">valarray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">getEncoderVals</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>

    
        

<h1 id="chassismodelparams-abstract">ChassisModelParams (Abstract)</h1>

<p>The <code>ChassisModelParams</code> class encapsulates the parameters a <code>ChassisModel</code> takes.</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">ChassisModelParams</span><span class="p">()</span>
</code></pre></div>

<p>The constructor does not take any parameters.</p>

<h2 id="make">make</h2>

<p>Allocate a new <code>ChassisModel</code> and return a <code>std::shared_ptr</code> to it. Most users will not have to call this, classes that take a <code>ChassisModel</code> will figure out the memory model themselves.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ChassisModel</span><span class="o">&gt;</span> <span class="n">make</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>

    
        

<h1 id="skidsteermodel">SkidSteerModel</h1>

<p>The <code>SkidSteerModel</code> class inherits from <code>ChassisModel</code> and takes a template parameter <code>size_t motorsPerSide</code> (the number of motors per each of the two sides of the chassis). It is a model for a skid steer drive (also called a tank drive).</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">SkidSteerModel</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;&amp;</span> <span class="n">imotorList</span><span class="p">,</span> <span class="n">Encoder</span> <span class="n">ileftEnc</span><span class="p">,</span> <span class="n">Encoder</span> <span class="n">irightEnc</span><span class="p">)</span>
<span class="n">SkidSteerModel</span><span class="p">(</span><span class="k">const</span> <span class="n">SkidSteerModelParams</span><span class="o">&lt;</span><span class="n">motorsPerSide</span><span class="o">&gt;&amp;</span> <span class="n">iparams</span><span class="p">)</span>
<span class="n">SkidSteerModel</span><span class="p">(</span><span class="k">const</span> <span class="n">SkidSteerModel</span><span class="o">&lt;</span><span class="n">motorsPerSide</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span>

<span class="c1">//Construct a SkidSteerModel with four motors (two per side) and two encoders</span>
<span class="c1">//Left side motors are ports 1 and 3</span>
<span class="c1">//Right side motors are ports 2 and 4</span>
<span class="c1">//Right side encoder is reversed because it is a mirror of the left side</span>
<span class="n">SkidSteerModel</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="n">encoderInit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">false</span><span class="p">),</span> <span class="n">encoderInit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imotorList</td>
<td>The left and right side motors for the drive in the format, <code>{left motors, right motors}</code></td>
</tr>

<tr>
<td>ileftEnc</td>
<td>The quadrature encoder for the left side</td>
</tr>

<tr>
<td>irightEnc</td>
<td>The quadrature encoder for the right side</td>
</tr>
</tbody>
</table>

    
        

<h1 id="skidsteermodelparams">SkidSteerModelParams</h1>

<p>The <code>SkidSteerModelParams</code> class inherits from <code>ChassisModelParams</code>. It encapsulates the parameters a <code>SkidSteerModel</code> takes.</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">SkidSteerModelParams</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;&amp;</span> <span class="n">imotorList</span><span class="p">,</span> <span class="n">Encoder</span> <span class="n">ileftEnc</span><span class="p">,</span> <span class="n">Encoder</span> <span class="n">irightEnc</span><span class="p">)</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imotorList</td>
<td>The left and right side motors for the drive in the format, <code>{left motors, right motors}</code></td>
</tr>

<tr>
<td>ileftEnc</td>
<td>The quadrature encoder for the left side</td>
</tr>

<tr>
<td>irightEnc</td>
<td>The quadrature encoder for the right side</td>
</tr>
</tbody>
</table>

    
        

<h1 id="xdrivemodel">XDriveModel</h1>

<p>The <code>XDriveModel</code> class inherits from <code>ChassisModel</code> and takes a template parameter <code>size_t motorsPerCorner</code> (the number of motors per each of the four corners of the chassis). It is a model for an x-drive.</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">XDriveModel</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;&amp;</span> <span class="n">imotorList</span><span class="p">,</span> <span class="n">Encoder</span> <span class="n">ileftEnc</span><span class="p">,</span> <span class="n">Encoder</span> <span class="n">irightEnc</span><span class="p">)</span>
<span class="n">XDriveModel</span><span class="p">(</span><span class="k">const</span> <span class="n">XDriveModelParams</span><span class="o">&lt;</span><span class="n">motorsPerCorner</span><span class="o">&gt;&amp;</span> <span class="n">iparams</span><span class="p">)</span>
<span class="n">XDriveModel</span><span class="p">(</span><span class="k">const</span> <span class="n">XDriveModel</span><span class="o">&lt;</span><span class="n">motorsPerCorner</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span>

<span class="c1">//Construct an XDriveModel with four motors (one per corner) and two encoders</span>
<span class="c1">//Top left motor is port 1, top right motor is port 2</span>
<span class="c1">//Bottom right motor is port 3, bottom left motor is port 4</span>
<span class="c1">//Right side encoder is reversed because it is a mirror of the left side</span>
<span class="n">XDriveModel</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="n">encoderInit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">false</span><span class="p">),</span> <span class="n">encoderInit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span>

<span class="c1">//Construct an XDriveModel with eight motors (two per corner) and two encoders</span>
<span class="c1">//Top left motors are ports 1 and 2, top right motors are ports 3 and 4</span>
<span class="c1">//Bottom right motors are ports 5 and 6, bottom left motors are ports 7 and 8</span>
<span class="c1">//Right side encoder is reversed because it is a mirror of the left side</span>
<span class="n">XDriveModel</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span> <span class="n">encoderInit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">false</span><span class="p">),</span> <span class="n">encoderInit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imotorList</td>
<td>The chassis motors for the drive in the clockwise format, <code>{top left motors, top right motors, bottom right motors, bottom left motors}</code></td>
</tr>

<tr>
<td>ileftEnc</td>
<td>The quadrature encoder for the left side</td>
</tr>

<tr>
<td>irightEnc</td>
<td>The quadrature encoder for the right side</td>
</tr>
</tbody>
</table>

    
        

<h1 id="xdrivemodelparams">XDriveModelParams</h1>

<p>The <code>XDriveModelParams</code> class inherits from <code>ChassisModelParams</code>. It encapsulates the parameters an <code>XDriveModel</code> takes.</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"> <span class="c1">//Signature</span>
 <span class="n">XDriveModelParams</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;&amp;</span> <span class="n">imotorList</span><span class="p">,</span> <span class="n">Encoder</span> <span class="n">ileftEnc</span><span class="p">,</span> <span class="n">Encoder</span> <span class="n">irightEnc</span><span class="p">)</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imotorList</td>
<td>The chassis motors for the drive in the clockwise format, <code>{top left motors, top right motors, bottom right motors, bottom left motors}</code></td>
</tr>

<tr>
<td>ileftEnc</td>
<td>The quadrature encoder for the left side</td>
</tr>

<tr>
<td>irightEnc</td>
<td>The quadrature encoder for the right side</td>
</tr>
</tbody>
</table>

    
        

<h1 id="filter-abstract">Filter (abstract)</h1>

<p>The <code>Filter</code> class is an interface for data filtering.</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">Filter</span><span class="p">()</span>
</code></pre></div>

<p>The constructor does not take any parameters.</p>

<h2 id="filter">filter</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">virtual</span> <span class="kt">float</span> <span class="nf">filter</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">ireading</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div>

<p>Filter an input and return the filtered output.</p>

<h2 id="getoutput">getOutput</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">virtual</span> <span class="kt">float</span> <span class="nf">getOutput</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div>

<p>Return the previous output.</p>

    
        

<h1 id="avgfilter">AvgFilter</h1>

<p>The <code>AvgFilter</code> class inherits from <code>Filter</code> and takes a template parameter <code>std::size_t n&gt;</code> (the number of inputs to average). It is a finite impulse response (FIR) filter that averages the last <code>n</code> inputs.</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">AvgFilter</span><span class="p">()</span>
</code></pre></div>

<p>The constructor does not take any parameters.</p>

    
        

<h1 id="emafilter">EmaFilter</h1>

<p>The <code>EmaFilter</code> class inherits from <code>Filter</code>. It is an infinite impulse response (IIR) filter that implements the exponential moving average algorithm (EMA).</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">EmaFilter</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">ialpha</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ibeta</span><span class="p">)</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ialpha</td>
<td>Alpha gain</td>
</tr>

<tr>
<td>ibeta</td>
<td>Beta gain</td>
</tr>
</tbody>
</table>

<h2 id="setgains">setGains</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">setGains</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">ialpha</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ibeta</span><span class="p">)</span>
</code></pre></div>

<p>Set new gains for this filter</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ialpha</td>
<td>New alpha gain</td>
</tr>

<tr>
<td>ibeta</td>
<td>New beta gain</td>
</tr>
</tbody>
</table>

    
        

<h1 id="demafilter">DemaFilter</h1>

<p>The <code>DemaFilter</code> class inherits from <code>Filter</code>. It is an infinite impulse response (IIR) filter that implements the double exponential moving average algorithm (EMA). This is very similar to the normal EMA, except it can pick up on trends in data and follow the current trend until a new trend starts. This filter performs better than a single EMA when data frequently follows a trend.</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">DemaFilter</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">ialpha</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ibeta</span><span class="p">)</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ialpha</td>
<td>Alpha gain</td>
</tr>

<tr>
<td>ibeta</td>
<td>Beta gain</td>
</tr>
</tbody>
</table>

<h2 id="setgains">setGains</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">setGains</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">ialpha</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ibeta</span><span class="p">)</span>
</code></pre></div>

<p>Set new gains for this filter</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ialpha</td>
<td>New alpha gain</td>
</tr>

<tr>
<td>ibeta</td>
<td>New beta gain</td>
</tr>
</tbody>
</table>

    
        

<h1 id="mathutil">MathUtil</h1>

<p>The <code>MathUtil</code> class provides <code>static constexpr</code> definitions for commonly used numbers, measurements, and conversion rates.</p>

<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>analogInToV</td>
<td>286.0</td>
<td>Converts an analog reading to a battery voltage measurement in Volts.</td>
</tr>

<tr>
<td>inchToMM</td>
<td>25.4</td>
<td>Converts one inch to millimeters.</td>
</tr>

<tr>
<td>degreeToRadian</td>
<td>0.01745</td>
<td>Converts one degree to radians.</td>
</tr>

<tr>
<td>radianToDegree</td>
<td>57.2958</td>
<td>Converts one radian to degrees.</td>
</tr>

<tr>
<td>imeHighTorTPR</td>
<td>627.2</td>
<td>The number of ticks an IME returns for one revolution of a 369 motor with high torque gearing.</td>
</tr>

<tr>
<td>imeHighStrTPR</td>
<td>392.0</td>
<td>The number of ticks an IME returns for one revolution of a 369 motor with high speed gearing.</td>
</tr>

<tr>
<td>imeTurboTPR</td>
<td>261.333</td>
<td>The number of ticks an IME returns for one revolution of a 369 motor with turbo gearing.</td>
</tr>

<tr>
<td>ime269TPR</td>
<td>240.448</td>
<td>The number of ticks an IME returns for one revolution of a 269 motor.</td>
</tr>

<tr>
<td>quadEncoderTPR</td>
<td>360.0</td>
<td>The number of ticks a quadrature encoder returns per revolution.</td>
</tr>

<tr>
<td>pi</td>
<td>3.14159265358979323846</td>
<td>The value of pi from GCC&rsquo;s math header (redefined here for convenience)</td>
</tr>
</tbody>
</table>

    
        

<h1 id="motionprofile">MotionProfile</h1>

<p>The <code>MotionProfile</code> class encapsulates the series of velocity and acceleration targets that make up a motion profile.</p>

<table>
<thead>
<tr>
<th>Member</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>data</td>
<td>A vector of velocity and acceleration targets</td>
</tr>

<tr>
<td>distance</td>
<td>The distance the motion profile travels</td>
</tr>

<tr>
<td>dt</td>
<td>The timestep between targets</td>
</tr>
</tbody>
</table>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">MotionProfile</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">idistance</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">idt</span><span class="p">)</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>idistance</td>
<td>The distance the motion profile travels</td>
</tr>

<tr>
<td>idt</td>
<td>The timestep between targets</td>
</tr>
</tbody>
</table>

<h1 id="mptarget">MPTarget</h1>

<p>The <code>MPTarget</code> class is designed to encapsulate a pair of velocity and acceleration targets for a motion profile.</p>

<table>
<thead>
<tr>
<th>Member</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>vel</td>
<td>A velocity target</td>
</tr>

<tr>
<td>accel</td>
<td>An acceleration target</td>
</tr>
</tbody>
</table>

<h2 id="constructor-1">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">MPTarget</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">velocity</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">acceleration</span><span class="p">)</span>
<span class="n">MPTarget</span><span class="p">()</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>vel</td>
<td>A velocity target</td>
</tr>

<tr>
<td>accel</td>
<td>An acceleration target</td>
</tr>
</tbody>
</table>

    
        

<h1 id="mpconsumer">MPConsumer</h1>

<p>The <code>MPConsumer</code> class is a feed-forward closed-loop controller that follows a pre-generated motion profile.</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">MPConsumer</span><span class="p">(</span><span class="n">MotionProfile</span> <span class="o">&amp;</span><span class="n">iprofile</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ikV</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ikA</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ikP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">MPConsumer</span><span class="p">(</span><span class="n">MotionProfile</span> <span class="o">&amp;</span><span class="n">iprofile</span><span class="p">,</span> <span class="k">const</span> <span class="n">MPConsumerParams</span><span class="o">&amp;</span> <span class="n">iparams</span><span class="p">)</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iprofile</td>
<td>A motion profile generated using <code>MPGenerator</code></td>
</tr>

<tr>
<td>ikV</td>
<td>Feed-forward velocity gain</td>
</tr>

<tr>
<td>ikA</td>
<td>Feed-forward acceleration gain</td>
</tr>

<tr>
<td>ikP</td>
<td>Feedback proportional gain (default = 0)</td>
</tr>
</tbody>
</table>

<h2 id="loop">loop</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">virtual</span> <span class="kt">float</span> <span class="n">loop</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">newReading</span><span class="p">)</span>
</code></pre></div>

<p>Loop the controller once over a new measurement and return the new response power.</p>

<h2 id="iscomplete">isComplete</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">bool</span> <span class="n">isComplete</span><span class="p">()</span> <span class="k">const</span>
</code></pre></div>

<p>Return whether the motion profile has been followed start to finish and is done.</p>

<h2 id="newprofile">newProfile</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">newProfile</span><span class="p">(</span><span class="n">MotionProfile</span><span class="o">&amp;</span> <span class="n">iprofile</span><span class="p">)</span>
</code></pre></div>

<p>Reinitialize this instance with a new motion profile. Also resets the internal <code>VelPid</code> controller.</p>

    
        

<h1 id="mpconsumerparams">MPConsumerParams</h1>

<p>The <code>MPConsumerParams</code> class encapsulates the parmaeters an <code>MPConsumer</code> takes.</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">MPConsumerParams</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">ikV</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ikA</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ikP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikV</td>
<td>Feed-forward velocity gain</td>
</tr>

<tr>
<td>ikA</td>
<td>Feed-forward acceleration gain</td>
</tr>

<tr>
<td>ikP</td>
<td>Feedback proportional gain (default = 0)</td>
</tr>
</tbody>
</table>

    
        

<h1 id="mpgenerator">MPGenerator</h1>

<p>The <code>MPGenerator</code> class is a motion profile generator. It accepts position, velocity, and acceleration bounds and produces a motion profile within those bounds.</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">MPGenerator</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">iaccel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">imaxVel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">itargetPos</span><span class="p">)</span>
<span class="n">MPGenerator</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">imaxAccel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">iminAccel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">imaxVel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">itargetPos</span><span class="p">)</span>
<span class="n">MPGenerator</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">imaxAccel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">iminAccel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">imaxVel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">itargetPos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">istartVel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">iendVel</span><span class="p">)</span>
<span class="n">MPGenerator</span><span class="p">(</span><span class="n">MPGenParams</span> <span class="n">iparams</span><span class="p">)</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imaxAccel</td>
<td>Maximum acceleration</td>
</tr>

<tr>
<td>iminAccel</td>
<td>Minimum acceleration (i.e., maximum deceleration, make sure this value is negative)</td>
</tr>

<tr>
<td>imaxVel</td>
<td>Maximum velocity</td>
</tr>

<tr>
<td>itargetPos</td>
<td>Target position (how far should the robot travel)</td>
</tr>

<tr>
<td>istartVel</td>
<td>Starting velocity (normally 0)</td>
</tr>

<tr>
<td>iendVel</td>
<td>Ending velocity (normally 0)</td>
</tr>
</tbody>
</table>

<h2 id="generateprofile">generateProfile</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">MotionProfile</span> <span class="n">generateProfile</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">idt</span><span class="p">)</span>
</code></pre></div>

<p>Generate and return a complete motion profile.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>idt</td>
<td>Timestep between targets</td>
</tr>
</tbody>
</table>

<h2 id="getnextveltarget">getNextVelTarget</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">MPTarget</span> <span class="n">getNextVelTarget</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">itime</span><span class="p">)</span>
</code></pre></div>

<p>Calculate and return the next velocity target in the motion profile.</p>

<h2 id="iscomplete">isComplete</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">bool</span> <span class="n">isComplete</span><span class="p">()</span> <span class="k">const</span>
</code></pre></div>

<p>Return whether the motion profile has been followed start to finish and is done.</p>

    
        

<h1 id="mpgeneratorparams">MPGeneratorParams</h1>

<p>The <code>MPGeneratorParams</code> class encapsulates the parameters an <code>MPGenerator</code> takes.</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">MPGenParams</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">imaxAccel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">iminAccel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">imaxVel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">itargetPos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">istartVel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">iendVel</span><span class="p">)</span>
<span class="n">MPGenParams</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">imaxAccel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">iminAccel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">imaxVel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">itargetPos</span><span class="p">)</span>
<span class="n">MPGenParams</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">iaccel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">imaxVel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">itargetPos</span><span class="p">)</span>
<span class="n">MPGenParams</span><span class="p">(</span><span class="k">const</span> <span class="n">MPGenParams</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imaxAccel</td>
<td>Maximum acceleration</td>
</tr>

<tr>
<td>iminAccel</td>
<td>Minimum acceleration (i.e., maximum deceleration, make sure this value is negative)</td>
</tr>

<tr>
<td>imaxVel</td>
<td>Maximum velocity</td>
</tr>

<tr>
<td>itargetPos</td>
<td>Target position (how far should the robot travel)</td>
</tr>

<tr>
<td>istartVel</td>
<td>Starting velocity (normally 0)</td>
</tr>

<tr>
<td>iendVel</td>
<td>Ending velocity (normally 0)</td>
</tr>
</tbody>
</table>

    
        

<h1 id="odommath">OdomMath</h1>

<p>The <code>OdomMath</code> class provides static implementations for common odometry operations.</p>

<h2 id="computedistancetopoint">computeDistanceToPoint</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">static</span> <span class="kt">float</span> <span class="n">computeDistanceToPoint</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">ix</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">iy</span><span class="p">,</span> <span class="k">const</span> <span class="n">OdomState</span><span class="o">&amp;</span> <span class="n">istate</span><span class="p">)</span>
</code></pre></div>

<p>Calculate the distance from the robot to a point, (<code>ix</code>, <code>iy</code>).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ix</td>
<td>X coordinate</td>
</tr>

<tr>
<td>iy</td>
<td>Y coordinate</td>
</tr>

<tr>
<td>istate</td>
<td>Odometry state</td>
</tr>
</tbody>
</table>

<h2 id="computeangletopoint">computeAngleToPoint</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">static</span> <span class="kt">float</span> <span class="n">computeAngleToPoint</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">ix</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">iy</span><span class="p">,</span> <span class="k">const</span> <span class="n">OdomState</span><span class="o">&amp;</span> <span class="n">istate</span><span class="p">)</span>
</code></pre></div>

<p>Calculate the angle from the robot to a point, (<code>ix</code>, <code>iy</code>).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ix</td>
<td>X coordinate</td>
</tr>

<tr>
<td>iy</td>
<td>Y coordinate</td>
</tr>

<tr>
<td>istate</td>
<td>Odometry state</td>
</tr>
</tbody>
</table>

<h2 id="computedistanceandangletopoint">computeDistanceAndAngleToPoint</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">static</span> <span class="n">DistanceAndAngle</span> <span class="n">computeDistanceAndAngleToPoint</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">ix</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">iy</span><span class="p">,</span> <span class="k">const</span> <span class="n">OdomState</span><span class="o">&amp;</span> <span class="n">istate</span><span class="p">)</span>
</code></pre></div>

<p>Calculate the distance and the angle from the robot to a point, (<code>ix</code>, <code>iy</code>).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ix</td>
<td>X coordinate</td>
</tr>

<tr>
<td>iy</td>
<td>Y coordinate</td>
</tr>

<tr>
<td>istate</td>
<td>Odometry state</td>
</tr>
</tbody>
</table>

<h1 id="distanceandangle">DistanceAndAngle</h1>

<p>The <code>DistanceAndAngle</code> class is a simple container for the two parameters returned by <code>OdomMath::computeDistanceAndAngleToPoint</code>.</p>

<table>
<thead>
<tr>
<th>Member</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>length</td>
<td>Distance to point</td>
</tr>

<tr>
<td>theta</td>
<td>Angle to point</td>
</tr>
</tbody>
</table>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">DistanceAndAngle</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">ilength</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">itheta</span><span class="p">)</span>
<span class="n">DistanceAndAngle</span><span class="p">()</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ilength</td>
<td>Distance to point</td>
</tr>

<tr>
<td>itheta</td>
<td>Angle to point</td>
</tr>
</tbody>
</table>

    
        

<h1 id="odometry">Odometry</h1>

<p>The <code>Odometry</code> class tracks the robot as it moves, computing its position in the field frame. It is a singleton so its main method, <code>loop</code>, can be called in a task.</p>

<h2 id="setparams">setParams</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">setParams</span><span class="p">(</span><span class="n">OdomParams</span><span class="o">&amp;</span> <span class="n">iparams</span><span class="p">)</span>
</code></pre></div>

<p>Set the model, scale, and turnScale parameters.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iparams</td>
<td><code>OdomParams</code></td>
</tr>
</tbody>
</table>

<h2 id="setscales">setScales</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">setScales</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">iscale</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">iturnScale</span><span class="p">)</span>
</code></pre></div>

<p>Set the scale and turnScale parameters.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iscale</td>
<td>Driving scale (encoder ticks to mm)</td>
</tr>

<tr>
<td>iturnScale</td>
<td>Turning scale (encoder ticks to degrees)</td>
</tr>
</tbody>
</table>

<h2 id="guessscales">guessScales</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">guessScales</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">chassisDiam</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">wheelDiam</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ticksPerRev</span> <span class="o">=</span> <span class="mf">360.0</span><span class="p">)</span>
</code></pre></div>

<p>Attempt to guess the two odometry scales from chassis and wheel diameter. This might get you close, but it serves only as a quick and temporary fix. The two odometry scales must be found experimentally for your specific robot.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>chassisDiam</td>
<td>Center-to-center wheel base in inches</td>
</tr>

<tr>
<td>wheelDiam</td>
<td>Edge-to-edge wheel diameter in inches</td>
</tr>

<tr>
<td>ticksPerRev</td>
<td>Quadrate encoder ticks per one wheel revolution (default 360)</td>
</tr>
</tbody>
</table>

<h2 id="loop">loop</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">static</span> <span class="n">OdomState</span> <span class="n">loop</span><span class="p">()</span>
</code></pre></div>

<p>Do one iteration of odometry math to compute the new position of the robot. This needs to be called every so many milliseconds (15 ms seems to work fine).</p>

<h2 id="getstate">getState</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">static</span> <span class="n">OdomState</span> <span class="n">getState</span><span class="p">()</span>
</code></pre></div>

<p>Return the last calculated position of the robot.</p>

<h1 id="odomparams">OdomParams</h1>

<p>The <code>OdomParams</code> class encapsulates the parameters an <code>Odometry</code> takes.</p>

<table>
<thead>
<tr>
<th>Member</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>model</td>
<td><code>ChassisModel</code></td>
</tr>

<tr>
<td>scale</td>
<td>Driving scale (encoder ticks to mm)</td>
</tr>

<tr>
<td>turnScale</td>
<td>Turning scale (encoder ticks to degrees)</td>
</tr>
</tbody>
</table>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">OdomParams</span><span class="p">(</span><span class="k">const</span> <span class="n">ChassisModelParams</span><span class="o">&amp;</span> <span class="n">iparams</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">iscale</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">iturnScale</span><span class="p">)</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iparams</td>
<td><code>ChassisModelParams</code> (used to make a new <code>ChassisModel</code>)</td>
</tr>

<tr>
<td>iscale</td>
<td>Driving scale (encoder ticks to mm)</td>
</tr>

<tr>
<td>iturnScale</td>
<td>Turning scale (encoder ticks to degrees)</td>
</tr>
</tbody>
</table>

<h1 id="odomstate">OdomState</h1>

<p>The <code>OdomState</code> class is a simple container for the position of the robot tracked by <code>Odometry</code>.</p>

<table>
<thead>
<tr>
<th>Member</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>x</td>
<td>X coordinate of robot</td>
</tr>

<tr>
<td>y</td>
<td>Y coordinate of robot</td>
</tr>

<tr>
<td>theta</td>
<td>Theta of robot</td>
</tr>
</tbody>
</table>

<h2 id="constructor-1">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">OdomState</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">ix</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">iy</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">itheta</span><span class="p">)</span>
<span class="n">OdomState</span><span class="p">()</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ix</td>
<td>X coordinate of robot</td>
</tr>

<tr>
<td>iy</td>
<td>Y coordinate of robot</td>
</tr>

<tr>
<td>itheta</td>
<td>Theta of robot</td>
</tr>
</tbody>
</table>

    
        

<h1 id="pid">Pid</h1>

<p>The <code>Pid</code> class implements the Pid algorithm, with some quality-of-life changes to support online tuning.</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">Pid</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">ikP</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ikI</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ikD</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ikBias</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">Pid</span><span class="p">(</span><span class="k">const</span> <span class="n">PidParams</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">)</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>ikI</td>
<td>Integral gain</td>
</tr>

<tr>
<td>ikD</td>
<td>Derivative gain</td>
</tr>

<tr>
<td>ikBias</td>
<td>Controller bias (this value added to output, default 0)</td>
</tr>

<tr>
<td>params</td>
<td><code>PidParams</code></td>
</tr>
</tbody>
</table>

<h2 id="loop">loop</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">virtual</span> <span class="kt">float</span> <span class="n">loop</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">inewReading</span><span class="p">)</span>
</code></pre></div>

<p>Do one iteration of Pid math to compute a new motor power. This needs to be called every so many milliseconds (15 ms works fine).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>inewReading</td>
<td>New sensor reading</td>
</tr>
</tbody>
</table>

<h2 id="setgains">setGains</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">setGains</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">ikP</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ikI</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ikD</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ikBias</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div>

<p>Set new controller gains and bias.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>ikI</td>
<td>Integral gain</td>
</tr>

<tr>
<td>ikD</td>
<td>Derivative gain</td>
</tr>

<tr>
<td>ikBias</td>
<td>Controller bias (this value added to output, default 0)</td>
</tr>
</tbody>
</table>

<h2 id="setsampletime">setSampleTime</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">setSampleTime</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">isampleTime</span><span class="p">)</span>
</code></pre></div>

<p>Set the timestep (in ms) between calls to <code>loop</code>.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>isampleTime</td>
<td>Timestep between calls to <code>loop</code> in ms</td>
</tr>
</tbody>
</table>

<h2 id="setoutputlimits">setOutputLimits</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">setOutputLimits</span><span class="p">(</span><span class="kt">float</span> <span class="n">imax</span><span class="p">,</span> <span class="kt">float</span> <span class="n">imin</span><span class="p">)</span>
</code></pre></div>

<p>Set the max and min value for the controller output.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imax</td>
<td>Max output</td>
</tr>

<tr>
<td>imin</td>
<td>Min output</td>
</tr>
</tbody>
</table>

<h2 id="setintegrallimits">setIntegralLimits</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">setIntegralLimits</span><span class="p">(</span><span class="kt">float</span> <span class="n">imax</span><span class="p">,</span> <span class="kt">float</span> <span class="n">imin</span><span class="p">)</span>
</code></pre></div>

<p>Set the max and min value for the integrator sum.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imax</td>
<td>Max integrator value</td>
</tr>

<tr>
<td>imin</td>
<td>Min integrator value</td>
</tr>
</tbody>
</table>

<h2 id="reset">reset</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">reset</span><span class="p">()</span>
</code></pre></div>

<p>Reset the controller so it will start from zero again.</p>

<h2 id="setintegratorreset">setIntegratorReset</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">setIntegratorReset</span><span class="p">(</span><span class="kt">bool</span> <span class="n">iresetOnZero</span><span class="p">)</span>
</code></pre></div>

<p>Set whether the integrator should be cleared when the controller&rsquo;s error is zero or changes sign.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iresetOnZero</td>
<td>Whether the integrator should be cleared when the controller&rsquo;s error is zero or changes sign</td>
</tr>
</tbody>
</table>

<h2 id="settarget">setTarget</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">setTarget</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">itarget</span><span class="p">)</span>
</code></pre></div>

<p>Set the target value.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>itarget</td>
<td>New target value</td>
</tr>
</tbody>
</table>

<h2 id="getoutput">getOutput</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">float</span> <span class="n">getOutput</span><span class="p">()</span> <span class="k">const</span>
</code></pre></div>

<p>Return the most recent controller output.</p>

<h1 id="pidparams">PidParams</h1>

<p>The <code>PidParams</code> class encapsulates the parameters a <code>Pid</code> takes.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>kP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>kI</td>
<td>Integral gain</td>
</tr>

<tr>
<td>kD</td>
<td>Derivative gain</td>
</tr>

<tr>
<td>kBias</td>
<td>Controller bias (this value added to output)</td>
</tr>
</tbody>
</table>

<h2 id="constructor-1">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">PidParams</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">ikP</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ikI</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ikD</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ikBias</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>ikI</td>
<td>Integral gain</td>
</tr>

<tr>
<td>ikD</td>
<td>Derivative gain</td>
</tr>

<tr>
<td>ikBias</td>
<td>Controller bias (this value added to output, default 0)</td>
</tr>
</tbody>
</table>

    
        

<h1 id="timer">Timer</h1>

<p>The <code>Timer</code> class has timing-related utilities to make measuring time differences and writing non-blocking code in loops easier.</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">Timer</span><span class="p">()</span>
</code></pre></div>

<p>The constructor does not take any parameters.</p>

<h2 id="getdt">getDt</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">getDt</span><span class="p">()</span>
</code></pre></div>

<p>Return the time passed in ms since the last time this function was called.</p>

<h2 id="getstartingtime">getStartingTime</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">getStartingTime</span><span class="p">()</span> <span class="k">const</span>
</code></pre></div>

<p>Return the time in ms the timer was constructed.</p>

<h2 id="getdtfromstart">getDtFromStart</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">getDtFromStart</span><span class="p">()</span> <span class="k">const</span>
</code></pre></div>

<p>Return the time passed in ms since the timer was constructed.</p>

<h2 id="placemark">placeMark</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">placeMark</span><span class="p">()</span>
</code></pre></div>

<p>Place a time marker. Placing another marker will overwrite the previous one.</p>

<h2 id="placehardmark">placeHardMark</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">placeHardMark</span><span class="p">()</span>
</code></pre></div>

<p>Place a hard time marker. Placing another hard marker will not overwrite the previous one; instead, <code>clearHardMark()</code> must be called before another can be placed.</p>

<h2 id="clearhardmark">clearHardMark</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clearHardMark</span><span class="p">()</span>
</code></pre></div>

<p>Clear and return the current hard marker.</p>

<h2 id="getdtfrommark">getDtFromMark</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">getDtFromMark</span><span class="p">()</span>
</code></pre></div>

<p>Return the time in ms since the marker was placed.</p>

<h2 id="getdtfromhardmark">getDtFromHardMark</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">getDtFromHardMark</span><span class="p">()</span>
</code></pre></div>

<p>Return the time in ms since the hard marker was placed.</p>

<h2 id="repeat">repeat</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">bool</span> <span class="n">repeat</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ms</span><span class="p">)</span>
</code></pre></div>

<p>Return true when the input time period <code>ms</code> has passed, and then reset. Meant to be used in loops to execute a block of code every so many ms without blocking the loop.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ms</td>
<td>Number of milliseconds between calls of <code>repeat</code> that return true</td>
</tr>
</tbody>
</table>

    
        

<h1 id="velpid">VelPid</h1>

<p>The <code>VelPid</code> class implements the Pid algorithm for the velocity domain, with some quality-of-life changes to support online tuning.</p>

<h2 id="constructor">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">VelPid</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">ikP</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ikD</span><span class="p">)</span>
<span class="n">VelPid</span><span class="p">(</span><span class="k">const</span> <span class="n">VelPidParams</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">)</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>ikI</td>
<td>Integral gain</td>
</tr>

<tr>
<td>ikD</td>
<td>Derivative gain</td>
</tr>

<tr>
<td>ikBias</td>
<td>Controller bias (this value added to output, default 0)</td>
</tr>

<tr>
<td>params</td>
<td><code>VelPidParams</code></td>
</tr>
</tbody>
</table>

<h2 id="loopvel">loopVel</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">virtual</span> <span class="kt">float</span> <span class="n">loopVel</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">inewReading</span><span class="p">)</span>
</code></pre></div>

<p>Do one iteration of velocity math to compute a new filtered velocity. This is only meant to be used separately from <code>loop</code> if you only want to compute a new velocity.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>inewReading</td>
<td>New sensor reading</td>
</tr>
</tbody>
</table>

<aside class="notice">
Don't call loopVel if you are already calling loop because loop will call loopVel on its own.
</aside>

<h2 id="loop">loop</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="k">virtual</span> <span class="kt">float</span> <span class="n">loop</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">inewReading</span><span class="p">)</span>
</code></pre></div>

<p>Do one iteration of Pid math to compute a new motor power. This needs to be called every so many milliseconds (15 ms works fine).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>inewReading</td>
<td>New sensor reading</td>
</tr>
</tbody>
</table>

<h2 id="setgains">setGains</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">setGains</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">ikP</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ikD</span><span class="p">)</span>
</code></pre></div>

<p>Set new controller gains and bias.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>ikD</td>
<td>Derivative gain</td>
</tr>
</tbody>
</table>

<h2 id="setfiltergains">setFilterGains</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">setFilterGains</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">alpha</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">beta</span><span class="p">)</span>
</code></pre></div>

<p>Set new gains for the <code>DemaFilter</code></p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>alpha</td>
<td>Alpha gain</td>
</tr>

<tr>
<td>beta</td>
<td>Beta gain</td>
</tr>
</tbody>
</table>

<h2 id="setsampletime">setSampleTime</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">setSampleTime</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">isampleTime</span><span class="p">)</span>
</code></pre></div>

<p>Set the timestep (in ms) between calls to <code>loop</code>.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>isampleTime</td>
<td>Timestep between calls to <code>loop</code> in ms</td>
</tr>
</tbody>
</table>

<h2 id="setticksperrev">setTicksPerRev</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">setTicksPerRev</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">tpr</span><span class="p">)</span>
</code></pre></div>

<p>Set the number of measurement units per revolution. Default is 360 (quadrature encoder).</p>

<h2 id="setoutputlimits">setOutputLimits</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">setOutputLimits</span><span class="p">(</span><span class="kt">float</span> <span class="n">imax</span><span class="p">,</span> <span class="kt">float</span> <span class="n">imin</span><span class="p">)</span>
</code></pre></div>

<p>Set the max and min value for the controller output.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imax</td>
<td>Max output</td>
</tr>

<tr>
<td>imin</td>
<td>Min output</td>
</tr>
</tbody>
</table>

<h2 id="reset">reset</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">reset</span><span class="p">()</span>
</code></pre></div>

<p>Reset the controller so it will start from zero again.</p>

<h2 id="settarget">setTarget</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">void</span> <span class="n">setTarget</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">itarget</span><span class="p">)</span>
</code></pre></div>

<p>Set the target value.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>itarget</td>
<td>New target value</td>
</tr>
</tbody>
</table>

<h2 id="getoutput">getOutput</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="kt">float</span> <span class="n">getOutput</span><span class="p">()</span> <span class="k">const</span>
</code></pre></div>

<p>Return the most recent controller output.</p>

<h1 id="velpidparams">VelPidParams</h1>

<p>The <code>VelPidParams</code> class encapsulates the parameters a <code>VelPid</code> takes.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>kP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>kD</td>
<td>Derivative gain</td>
</tr>
</tbody>
</table>

<h2 id="constructor-1">Constructor</h2>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//Signature</span>
<span class="n">VelPidParams</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">ikP</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ikD</span><span class="p">)</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>ikD</td>
<td>Derivative gain</td>
</tr>
</tbody>
</table>

    

        </div>
        <div class="dark-box">
            
        </div>
    </div>
    
</body>
</html>
