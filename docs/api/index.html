<!DOCTYPE html>
  
  
  
  
   <html class="no-js"> 

  <head lang="en-us">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=10" />
    <title>API Reference - Okapi Docs</title>
    <meta name="generator" content="Hugo 0.30" />

    
    <meta name="description" content="A PROS library for fast C&#43;&#43; development.">
    
    <link rel="canonical" href="https://okapilib.github.io/OkapiLib/api/">
    
    <meta name="author" content="OkapiLib">
    

    <meta property="og:url" content="https://okapilib.github.io/OkapiLib/api/">
    <meta property="og:title" content="Okapi Docs">
    <meta property="og:image" content="https://okapilib.github.io/OkapiLib/images/logo.png">
    <meta name="apple-mobile-web-app-title" content="Okapi Docs">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="shortcut icon" type="image/x-icon" href="https://okapilib.github.io/OkapiLib/images/favicon.ico">
    <link rel="icon" type="image/x-icon" href="https://okapilib.github.io/OkapiLib/images/favicon.ico">

    <style>
      @font-face {
        font-family: 'Icon';
        src: url('https://okapilib.github.io/OkapiLib/fonts/icon.eot');
        src: url('https://okapilib.github.io/OkapiLib/fonts/icon.eot')
               format('embedded-opentype'),
             url('https://okapilib.github.io/OkapiLib/fonts/icon.woff')
               format('woff'),
             url('https://okapilib.github.io/OkapiLib/fonts/icon.ttf')
               format('truetype'),
             url('https://okapilib.github.io/OkapiLib/fonts/icon.svg')
               format('svg');
        font-weight: normal;
        font-style: normal;
      }
    </style>

    <link rel="stylesheet" href="https://okapilib.github.io/OkapiLib/stylesheets/application.css">
    <link rel="stylesheet" href="https://okapilib.github.io/OkapiLib/stylesheets/temporary.css">
    <link rel="stylesheet" href="https://okapilib.github.io/OkapiLib/stylesheets/palettes.css">
    <link rel="stylesheet" href="https://okapilib.github.io/OkapiLib/stylesheets/highlight/highlight.css">

    
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ubuntu:400,700|Ubuntu&#43;Mono">
    <style>
      body, input {
        font-family: 'Ubuntu', Helvetica, Arial, sans-serif;
      }
      pre, code {
        font-family: 'Ubuntu Mono', 'Courier New', 'Courier', monospace;
      }
    </style>

    
    <script src="https://okapilib.github.io/OkapiLib/javascripts/modernizr.js"></script>

    

  </head>
  <body class="palette-primary-red palette-accent-teal">



	
	


<div class="backdrop">
	<div class="backdrop-paper"></div>
</div>

<input class="toggle" type="checkbox" id="toggle-drawer">
<input class="toggle" type="checkbox" id="toggle-search">
<label class="toggle-button overlay" for="toggle-drawer"></label>

<header class="header">
	<nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        API Reference
      </div>
    </div>

    

    
    <div class="button button-github" role="button" aria-label="GitHub">
      <a href="https://github.com/OkapiLib" title="@OkapiLib on GitHub" target="_blank" class="toggle-button icon icon-github"></a>
    </div>
    
    
        
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
</header>

<main class="main">
	<div class="drawer">
		<nav aria-label="Navigation">
  <a href="https://github.com/OkapiLib/OkapiLib" class="project">
    <div class="banner">
      
        <div class="logo">
          <img src="https://okapilib.github.io/OkapiLib/images/logo.png">
        </div>
      
      <div class="name">
        <strong>Okapi Docs <span class="version">0.1.1</span></strong>
        
          <br>
          OkapiLib/OkapiLib
        
      </div>
    </div>
  </a>

  <div class="scrollable">
    <div class="wrapper">
      
        <ul class="repo">
          <li class="repo-download">
            <a href="https://github.com/OkapiLib/OkapiLib/archive/master.zip" target="_blank" title="Download" data-action="download">
              <i class="icon icon-download"></i> Download
            </a>
          </li>
          <li class="repo-stars">
            <a href="https://github.com/OkapiLib/OkapiLib/stargazers" target="_blank" title="Stargazers" data-action="star">
              <i class="icon icon-star"></i> Stars
              <span class="count">&ndash;</span>
            </a>
          </li>
        </ul>
        <hr>
      

      <div class="toc">
        
        <ul>
          




<li>
  
    



<a  title="Home" href="https://okapilib.github.io/OkapiLib/">
	
	Home
</a>



  
</li>



<li>
  
    



<a  title="Getting started" href="https://okapilib.github.io/OkapiLib/getting-started/">
	
	Getting started
</a>



  
</li>



<li>
  
    



<a  title="Tutorials" href="https://okapilib.github.io/OkapiLib/tutorials/">
	
	Tutorials
</a>



  
</li>



<li>
  
    



<a class="current" title="API" href="https://okapilib.github.io/OkapiLib/api/">
	
	API
</a>


<ul id="scrollspy">
</ul>


  
</li>



<li>
  
    



<a  title="License" href="https://okapilib.github.io/OkapiLib/license/">
	
	License
</a>



  
</li>


        </ul>
        

        
        <hr>
        <span class="section">The author</span>
        
        <ul>
          

          
          <li>
            <a href="https://github.com/OkapiLib" target="_blank" title="@OkapiLib on GitHub">
              @OkapiLib on GitHub
            </a>
          </li>
          

          
        </ul>
        
      </div>
    </div>
  </div>
</nav>

	</div>

	<article class="article">
		<div class="wrapper">
			<h1>API Reference </h1>

			<p>This section is meant to be a quick reference for Okapi&rsquo;s entire API, including methods the user may not normally interact with. This reference is broken into sections, covering one class per section. Subclasses are placed below the base class, but in different sections. If a class is marked (abstract) then it contains one or more pure virtual functions, and cannot be instantiated (it is designed only to be an interface).</p>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Remember that derived classes inherit the interface of their base class; therefore, derived classes will not have their base class&rsquo; functions documented (you can safely assume that all functions from the base class are implemented).</p>
</div>

<p><h2 id="avgfilter">AvgFilter</h2>

<p>The <code>AvgFilter</code> class inherits from <code>Filter</code> and takes a template parameter <code>std::size_t n&gt;</code> (the number of inputs to average). It is a finite impulse response (FIR) filter that averages the last <code>n</code> inputs.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
AvgFilter()
</code></pre>

<p>The constructor does not take any parameters.</p>

<h2 id="button">Button</h2>

<p>The <code>Button</code> class is a sample wrapper around a digital input port that represents a button.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
explicit constexpr Button()
explicit constexpr Button(const unsigned long long int iport)
explicit constexpr Button(const unsigned long long int iport, const bool iinverted)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iport</td>
<td>Digital port</td>
</tr>

<tr>
<td>iinverted</td>
<td>Whether the button is inverted (default open vs. default closed)</td>
</tr>
</tbody>
</table>

<p>This class also has literals available:</p>

<table>
<thead>
<tr>
<th>Literal</th>
<th>Button Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>n_b</code></td>
<td><code>Button(n, false)</code></td>
</tr>

<tr>
<td><code>n_ib</code></td>
<td><code>Button(n, true)</code></td>
</tr>
</tbody>
</table>

<h3 id="ispressed">isPressed</h3>

<pre><code class="language-c++">//Signature
bool isPressed() const
</code></pre>

<p>Return whether this button is pressed or not. This takes into account whether the button is inverted or not.</p>

<h2 id="chassiscontroller-abstract">ChassisController (abstract)</h2>

<p>The <code>ChassisController</code> class an interface for controlling a robot&rsquo;s chassis: it provides methods that build upon the basic methods <code>ChassisModel</code> has for more accurate control.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
ChassisController(const ChassisModelParams&amp; imodelParams)
ChassisController(std::shared_ptr&lt;ChassisModel&gt; imodel)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imodelParams</td>
<td><code>ChassisModelParams</code> (used to make a new <code>ChassisModel</code>)</td>
</tr>

<tr>
<td>imodel</td>
<td>An existing <code>ChassisModel</code></td>
</tr>
</tbody>
</table>

<h3 id="drivestraight">driveStraight</h3>

<pre><code class="language-c++">//Signature
virtual void driveStraight(const int itarget) = 0
</code></pre>

<p>Drive the robot straight for a distance of <code>itarget</code> in the units of <code>itarget</code>.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>itarget</td>
<td>Distance for the robot to travel</td>
</tr>
</tbody>
</table>

<h3 id="pointturn">pointTurn</h3>

<pre><code class="language-c++">//Signature
virtual void pointTurn(const float idegTarget) = 0
</code></pre>

<p>Turn the robot in place for an angle of <code>idegTarget</code>. The units of the angle travel is most often the difference in encoder ticks between the two sides of the chassis.</p>

<h3 id="driveforward">driveForward</h3>

<pre><code class="language-c++">//Signature
void driveForward(const int power)
</code></pre>

<p>Passthrough function to call <code>driveForward</code> on the internal <code>ChassisModel</code>.</p>

<h3 id="drivevector">driveVector</h3>

<pre><code class="language-c++">//Signature
void driveVector(const int distPower, const int anglePower)
</code></pre>

<p>Passthrough function to call <code>driveVector</code> on the internal <code>ChassisModel</code>.</p>

<h3 id="turnclockwise">turnClockwise</h3>

<pre><code class="language-c++">//Signature
void turnClockwise(const int power)
</code></pre>

<p>Passthrough function to call <code>turnClockwise</code> on the internal <code>ChassisModel</code>.</p>

<h3 id="tank">tank</h3>

<pre><code class="language-c++">//Signature
void tank(const int leftVal, const int rightVal)
</code></pre>

<p>Passthrough function to call <code>tank</code> on the internal <code>ChassisModel</code></p>

<h3 id="arcade">arcade</h3>

<pre><code class="language-c++">//Signature
void arcade(const int verticalVal, const int horizontalVal)
</code></pre>

<p>Passthrough function to call <code>arcade</code> on the internal <code>ChassisModel</code></p>

<h3 id="getencodervals">getEncoderVals</h3>

<pre><code class="language-c++">//Signature
std::valarray&lt;int&gt; getEncoderVals() const
</code></pre>

<p>Passthrough function to call <code>getEncoderVals</code> on the internal <code>ChassisModel</code>.</p>

<h2 id="chassiscontrollermp">ChassisControllerMP</h2>

<p>The <code>ChassisControllerMP</code> class inherits from <code>ChassisController</code> and implements its interface using motion profiling.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
ChassisControllerMP(const ChassisModelParams&amp; imodelParams, const MPControllerParams&amp; iparams)
ChassisControllerMP(const std::shared_ptr&lt;ChassisModel&gt;&amp; imodel, const MPControllerParams&amp; iparams)

//Make a new ChassisControllerMP using a skid steer model with two motors per side
ChassisControllerMP foo(
  SkidSteerModelParams&lt;2&gt;({1, 3, 2, 4}, //The four motor ports
                          encoderInit(1, 2, false), //Left encoder
                          encoderInit(3, 4, true)), //Right encoder
  MPControllerParams(
    MPGenParams(1, 15, 1000),        //MPGenerator params; max &amp; min accel: 1, max vel: 15, target pos: 1000
    MPConsumerParams(6, 1.2, 0.5))); //MPConsumer params; kV: 6, kA: 1.2, kP: 0.5
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imodelParams</td>
<td><code>ChassisModelParams</code> (used to make a new <code>ChassisModel</code>)</td>
</tr>

<tr>
<td>imodel</td>
<td>An existing <code>ChassisModel</code></td>
</tr>

<tr>
<td>igenParams</td>
<td><code>MPGenParams</code> (used to make a new <code>MPGenerator</code>)</td>
</tr>

<tr>
<td>icParams</td>
<td><code>MPConsumerParams</code> (used to make a new <code>MPConsumer</code>)</td>
</tr>
</tbody>
</table>

<div class="admonition warning">
<p class="admonition-title">Careful</p>
<p>Most users should not call this constructor with a std::shared_ptr&lt;ChassisModel&gt;. Instead, pass a ChassisModelParams and Okapi will figure out what to do.</p>
</div>
<h2 id="chassiscontrollerpid">ChassisControllerPid</h2>

<p>The <code>ChassisControllerPid</code> class inherits from <code>ChassisController</code> and implements its interface using PID control.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
ChassisControllerPid(const ChassisModelParams&amp; imodelParams, const PidParams&amp; idistanceParams, const PidParams&amp; iangleParams)
ChassisControllerPid(const std::shared_ptr&lt;ChassisModel&gt;&amp; imodel, const PidParams&amp; idistanceParams, const PidParams&amp; iangleParams)

//Make a new ChassisControllerPid using a skid steer model with two motors per side
ChassisControllerPid foo(
  SkidSteerModelParams&lt;2&gt;({1, 3, 2, 4}, //The four motor ports
                          encoderInit(1, 2, false), //Left encoder
                          encoderInit(3, 4, true)), //Right encoder
  PidParams(2, 0.1, 0.4),    //Distance PID controller
  PidParams(0.3, 1.2, 0.1)); //Angle PID controller
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imodelParams</td>
<td><code>ChassisModelParams</code> (used to make a new <code>ChassisModel</code>)</td>
</tr>

<tr>
<td>imodel</td>
<td>An existing <code>ChassisModel</code></td>
</tr>

<tr>
<td>idistanceParams</td>
<td><code>PidParams</code> for the distance PID controller</td>
</tr>

<tr>
<td>iangleParams</td>
<td><code>PidParams</code> for the angle PID controller</td>
</tr>
</tbody>
</table>

<div class="admonition warning">
<p class="admonition-title">Careful</p>
<p>Most users should not call this constructor with a std::shared_ptr&lt;ChassisModel&gt;. Instead, pass a ChassisModelParams and Okapi will figure out what to do.</p>
</div>
<h2 id="chassismodel-abstract">ChassisModel (abstract)</h2>

<p>The <code>ChassisModel</code> class is an interface to a robot&rsquo;s chassis: it provides methods to control the chassis and to read from standard sensors placed on most chassis (i.e., quadrature encoders).</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
ChassisModel()
</code></pre>

<p>The constructor does not take any parameters.</p>

<h3 id="driveforward">driveForward</h3>

<pre><code class="language-c++">//Signature
virtual void driveForward(const int power) = 0
</code></pre>

<p>Drives the chassis forwards by setting all motors to the input power. A positive value for <code>power</code> should cause all chassis wheels to move the robot forward in a straight line.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>power</td>
<td>The raw motor power sent directly to the chassis&rsquo; motors</td>
</tr>
</tbody>
</table>

<h3 id="turnclockwise">turnClockwise</h3>

<pre><code class="language-c++">//Signature
virtual void turnClockwise(const int power) = 0
</code></pre>

<p>Turns the robot clockwise by setting the left side motors to the input power and the right side motors to the negative of the input power. A positive value for <code>power</code> should cause all chassis wheels to turn the robot clockwise on a point.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>power</td>
<td>The raw motor power sent directly to the chassis&rsquo; motors</td>
</tr>
</tbody>
</table>

<h3 id="drivevector">driveVector</h3>

<pre><code class="language-c++">//Signature
virtual void driveVector(const int distPower, const int anglePower) = 0

driveVector(127, 0) //Same as driveForward(127)
driveVector(0, 127) //Same as turnClockwise(127)

//Make a moderate swing turn clockwise
//left motors get 110 power, right motors get 70 power
driveVector(90, 20)
</code></pre>

<p>Drive the chassis along a curved path. Calling <code>driveVector(127, 0)</code> should be equivalent to calling <code>driveForward(127)</code>; calling <code>driveVector(0, 127)</code> should be equivalent to calling <code>turnClockwise(127)</code>. A mix between the two will cause the robot to make a swing turn.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>distPower</td>
<td>The motor power making up the &ldquo;straight&rdquo; component of the final motor power</td>
</tr>

<tr>
<td>anglePower</td>
<td>The motor power making up the &ldquo;turn&rdquo; component of the final motor power</td>
</tr>
</tbody>
</table>

<h3 id="tank">tank</h3>

<pre><code class="language-c++">//Signature
virtual void tank(const int leftVal, const int rightVal) = 0;
</code></pre>

<p>Power the motors like tank drive.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>leftVal</td>
<td>Motor power for the left side motors</td>
</tr>

<tr>
<td>rightVal</td>
<td>Motor power for the right side motors</td>
</tr>
</tbody>
</table>

<h3 id="arcade">arcade</h3>

<pre><code class="language-c++">//Signature
virtual void arcade(const int verticalVal, const int horizontalVal) = 0;
</code></pre>

<p>Power the motors like arcade drive.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>verticalVal</td>
<td>Motor power for the vertical component of movement</td>
</tr>

<tr>
<td>horizontalVal</td>
<td>Motor power for the horizontal component of movement</td>
</tr>
</tbody>
</table>

<h3 id="getencodervals">getEncoderVals</h3>

<p>Reads the encoders given to the chassis model at construction time and returns them in the format <code>{left encoder value, right encoder value}</code>. Return type is a <code>std::valarray</code> because it features operator overrides for common math operations making encoder math easy.</p>

<pre><code class="language-c++">//Signature
virtual std::valarray&lt;int&gt; getEncoderVals() const = 0
</code></pre>

<h2 id="chassismodelparams-abstract">ChassisModelParams (Abstract)</h2>

<p>The <code>ChassisModelParams</code> class encapsulates the parameters a <code>ChassisModel</code> takes.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
ChassisModelParams()
</code></pre>

<p>The constructor does not take any parameters.</p>

<h3 id="make">make</h3>

<p>Allocate a new <code>ChassisModel</code> and return a <code>std::shared_ptr</code> to it. Most users will not have to call this, classes that take a <code>ChassisModel</code> will figure out the memory model themselves.</p>

<pre><code class="language-c++">//Signature
virtual std::shared_ptr&lt;ChassisModel&gt; make() const = 0
</code></pre>

<h2 id="controlobject">ControlObject</h2>

<p>docs
<h2 id="cubicmotor">CubicMotor</h2>

<p>The <code>CubicMotor</code> class provides a cubic-control based implementation of the <code>set</code> function <code>Motor</code> defines. This means that the motor power from <code>set</code> follows a cubic curve instead of the default identity function. The <code>setTS</code> function is not overridden and so provides the same behavior as in <code>Motor</code>.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
explicit constexpr CubicMotor()
explicit constexpr CubicMotor(const int iport, const int isign)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iport</td>
<td>Motor port</td>
</tr>

<tr>
<td>isign</td>
<td><code>1</code> for forward, <code>-1</code> for reversed</td>
</tr>
</tbody>
</table>

<p>This class also has literals available:</p>

<table>
<thead>
<tr>
<th>Literal</th>
<th>Motor Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>n_m3</code></td>
<td><code>CubicMotor(m, 1)</code></td>
</tr>

<tr>
<td><code>n_rm3</code></td>
<td><code>CubicMotor(m, -1)</code></td>
</tr>
</tbody>
</table>

<h3 id="set">set</h3>

<pre><code class="language-c++">//Signature
virtual void set(const int val) const
</code></pre>

<p>Set the power of this motor using a cubic function. The exact math for the output of this function is <code>(val * val * val) / (127 * 127)</code>.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>val</td>
<td>Motor power</td>
</tr>
</tbody>
</table>

<h2 id="demafilter">DemaFilter</h2>

<p>The <code>DemaFilter</code> class inherits from <code>Filter</code>. It is an infinite impulse response (IIR) filter that implements the double exponential moving average algorithm (EMA). This is very similar to the normal EMA, except it can pick up on trends in data and follow the current trend until a new trend starts. This filter performs better than a single EMA when data frequently follows a trend.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
DemaFilter(const float ialpha, const float ibeta)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ialpha</td>
<td>Alpha gain</td>
</tr>

<tr>
<td>ibeta</td>
<td>Beta gain</td>
</tr>
</tbody>
</table>

<h3 id="setgains">setGains</h3>

<pre><code class="language-c++">//Signature
void setGains(const float ialpha, const float ibeta)
</code></pre>

<p>Set new gains for this filter</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ialpha</td>
<td>New alpha gain</td>
</tr>

<tr>
<td>ibeta</td>
<td>New beta gain</td>
</tr>
</tbody>
</table>

<h2 id="distanceandangle">DistanceAndAngle</h2>

<p>The <code>DistanceAndAngle</code> class is a simple container for the two parameters returned by <code>OdomMath::computeDistanceAndAngleToPoint</code>.</p>

<table>
<thead>
<tr>
<th>Member</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>length</td>
<td>Distance to point</td>
</tr>

<tr>
<td>theta</td>
<td>Angle to point</td>
</tr>
</tbody>
</table>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
DistanceAndAngle(const float ilength, const float itheta)
DistanceAndAngle()
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ilength</td>
<td>Distance to point</td>
</tr>

<tr>
<td>itheta</td>
<td>Angle to point</td>
</tr>
</tbody>
</table>

<h2 id="emafilter">EmaFilter</h2>

<p>The <code>EmaFilter</code> class inherits from <code>Filter</code>. It is an infinite impulse response (IIR) filter that implements the exponential moving average algorithm (EMA).</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
EmaFilter(const float ialpha, const float ibeta)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ialpha</td>
<td>Alpha gain</td>
</tr>

<tr>
<td>ibeta</td>
<td>Beta gain</td>
</tr>
</tbody>
</table>

<h3 id="setgains">setGains</h3>

<pre><code class="language-c++">//Signature
void setGains(const float ialpha, const float ibeta)
</code></pre>

<p>Set new gains for this filter</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ialpha</td>
<td>New alpha gain</td>
</tr>

<tr>
<td>ibeta</td>
<td>New beta gain</td>
</tr>
</tbody>
</table>

<h2 id="filter-abstract">Filter (abstract)</h2>

<p>The <code>Filter</code> class is an interface for data filtering.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
Filter()
</code></pre>

<p>The constructor does not take any parameters.</p>

<h3 id="filter">filter</h3>

<pre><code class="language-c++">//Signature
virtual float filter(const float ireading) = 0;
</code></pre>

<p>Filter an input and return the filtered output.</p>

<h3 id="getoutput">getOutput</h3>

<pre><code class="language-c++">//Signature
virtual float getOutput() const = 0;
</code></pre>

<p>Return the previous output.</p>

<h2 id="genericcontroller">GenericController</h2>

<p>The <code>GenericController</code> class combines motors and a <code>ControlObject</code> into one package that uses the controller to control the motors as a group (all motors get the same controller output).</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
GenericController(const std::array&lt;Motor, motorNum&gt; &amp;imotorList, const std::shared_ptr&lt;ControlObject&gt; &amp;iptr)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imotorList</td>
<td><code>std::array</code> of <code>Motor</code> that will be controlled</td>
</tr>

<tr>
<td>iptr</td>
<td><code>ControlObject</code> used to control the motors</td>
</tr>
</tbody>
</table>

<h3 id="loop">loop</h3>

<pre><code class="language-c++">//Signature
void loop(const float ireading)
</code></pre>

<p>Have the <code>ControlObject</code> do one iteration and then power the motors with the output. This needs to be called every so many milliseconds (15 ms works fine).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ireading</td>
<td>New sensor reading</td>
</tr>
</tbody>
</table>

<h3 id="settarget">setTarget</h3>

<pre><code class="language-c++">//Signature
void setTarget(const float itarget)
</code></pre>

<p>Set the target value.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>itarget</td>
<td>New target value</td>
</tr>
</tbody>
</table>

<h3 id="getoutput">getOutput</h3>

<pre><code class="language-c++">//Signature
void getOutput() const
</code></pre>

<p>Return the most recent controller output.</p>

<h3 id="setsampletime">setSampleTime</h3>

<pre><code class="language-c++">//Signature
void setSampleTime(const int isampleTime)
</code></pre>

<p>Set the timestep (in ms) between calls to <code>loop</code>.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>isampleTime</td>
<td>Timestep between calls to <code>loop</code> in ms</td>
</tr>
</tbody>
</table>

<h3 id="setoutputlimits">setOutputLimits</h3>

<pre><code class="language-c++">//Signature
void setOutputLimits(float imax, float imin)
</code></pre>

<p>Set the max and min value for the controller output.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imax</td>
<td>Max output</td>
</tr>

<tr>
<td>imin</td>
<td>Min output</td>
</tr>
</tbody>
</table>

<h3 id="reset">reset</h3>

<pre><code class="language-c++">//Signature
void reset()
</code></pre>

<p>Reset the controller so it will start from zero again.</p>

<h3 id="flipdisable">flipDisable</h3>

<pre><code class="language-c++">//Signature
void flipDisable()
</code></pre>

<p>Change whether the controller is on or off. A controller which is off will output 0.</p>

<h2 id="mathutil">MathUtil</h2>

<p>The <code>MathUtil</code> class provides <code>static constexpr</code> definitions for commonly used numbers, measurements, and conversion rates.</p>

<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>analogInToV</td>
<td>286.0</td>
<td>Converts an analog reading to a battery voltage measurement in Volts.</td>
</tr>

<tr>
<td>inchToMM</td>
<td>25.4</td>
<td>Converts one inch to millimeters.</td>
</tr>

<tr>
<td>degreeToRadian</td>
<td>0.01745</td>
<td>Converts one degree to radians.</td>
</tr>

<tr>
<td>radianToDegree</td>
<td>57.2958</td>
<td>Converts one radian to degrees.</td>
</tr>

<tr>
<td>imeHighTorTPR</td>
<td>627.2</td>
<td>The number of ticks an IME returns for one revolution of a 369 motor with high torque gearing.</td>
</tr>

<tr>
<td>imeHighStrTPR</td>
<td>392.0</td>
<td>The number of ticks an IME returns for one revolution of a 369 motor with high speed gearing.</td>
</tr>

<tr>
<td>imeTurboTPR</td>
<td>261.333</td>
<td>The number of ticks an IME returns for one revolution of a 369 motor with turbo gearing.</td>
</tr>

<tr>
<td>ime269TPR</td>
<td>240.448</td>
<td>The number of ticks an IME returns for one revolution of a 269 motor.</td>
</tr>

<tr>
<td>quadEncoderTPR</td>
<td>360.0</td>
<td>The number of ticks a quadrature encoder returns per revolution.</td>
</tr>

<tr>
<td>pi</td>
<td>3.14159265358979323846</td>
<td>The value of pi from GCC&rsquo;s math header (redefined here for convenience)</td>
</tr>
</tbody>
</table>

<h2 id="motionprofile">MotionProfile</h2>

<p>The <code>MotionProfile</code> class encapsulates the series of velocity and acceleration targets that make up a motion profile.</p>

<table>
<thead>
<tr>
<th>Member</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>data</td>
<td>A vector of velocity and acceleration targets</td>
</tr>

<tr>
<td>distance</td>
<td>The distance the motion profile travels</td>
</tr>

<tr>
<td>dt</td>
<td>The timestep between targets</td>
</tr>
</tbody>
</table>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
MotionProfile(const float idistance, const float idt)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>idistance</td>
<td>The distance the motion profile travels</td>
</tr>

<tr>
<td>idt</td>
<td>The timestep between targets</td>
</tr>
</tbody>
</table>

<h3 id="operator">operator[]</h3>

<p>Pass the <code>operator[]</code> onto the internal std::vector.</p>

<h3 id="size">size</h3>

<pre><code class="language-c++">//Signature
int size() const
</code></pre>

<p>Return the size of the internal std::vector.</p>

<h2 id="mptarget">MPTarget</h2>

<p>The <code>MPTarget</code> class is designed to encapsulate a pair of velocity and acceleration targets for a motion profile.</p>

<table>
<thead>
<tr>
<th>Member</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>vel</td>
<td>A velocity target</td>
</tr>

<tr>
<td>accel</td>
<td>An acceleration target</td>
</tr>
</tbody>
</table>

<h3 id="constructor-1">Constructor</h3>

<pre><code class="language-c++">//Signature
MPTarget(const float velocity, const float acceleration)
MPTarget()
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>vel</td>
<td>A velocity target</td>
</tr>

<tr>
<td>accel</td>
<td>An acceleration target</td>
</tr>
</tbody>
</table>

<h2 id="motor">Motor</h2>

<p>The <code>Motor</code> class provides a wrapper around the default motor utilities.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
explicit constexpr Motor()
explicit constexpr Motor(const int iport, const int isign)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iport</td>
<td>Motor port</td>
</tr>

<tr>
<td>isign</td>
<td><code>1</code> for forward, <code>-1</code> for reversed</td>
</tr>
</tbody>
</table>

<p>This class also has literals available:</p>

<table>
<thead>
<tr>
<th>Literal</th>
<th>Motor Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>n_m</code></td>
<td><code>Motor(m, 1)</code></td>
</tr>

<tr>
<td><code>n_rm</code></td>
<td><code>Motor(m, -1)</code></td>
</tr>
</tbody>
</table>

<h3 id="set">set</h3>

<pre><code class="language-c++">//Signature
virtual void set(const int val) const
</code></pre>

<p>Set the power of this motor.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>val</td>
<td>Motor power</td>
</tr>
</tbody>
</table>

<h3 id="setts">setTS</h3>

<pre><code class="language-c++">//Signature
virtual void set(const int val) const
</code></pre>

<p>Set the power of this motor using trueSpeed. The trueSpeed array can be changed in the file <code>include/device/motor.h</code>.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>val</td>
<td>Motor power</td>
</tr>
</tbody>
</table>

<h2 id="mpconsumer">MPConsumer</h2>

<p>The <code>MPConsumer</code> class is a feed-forward closed-loop controller that follows a pre-generated motion profile.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
MPConsumer(const float ikV, const float ikA, const float ikP = 0)
MPConsumer(const MPConsumerParams&amp; iparams)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iprofile</td>
<td>A motion profile generated using <code>MPGenerator</code></td>
</tr>

<tr>
<td>ikV</td>
<td>Feed-forward velocity gain</td>
</tr>

<tr>
<td>ikA</td>
<td>Feed-forward acceleration gain</td>
</tr>

<tr>
<td>ikP</td>
<td>Feedback proportional gain (default = 0)</td>
</tr>
</tbody>
</table>

<h3 id="loop">loop</h3>

<pre><code class="language-c++">//Signature
virtual float loop(const MotionProfile&amp; profile, const float newReading)
</code></pre>

<p>Loop the controller once over a new measurement and return the new response power.</p>

<h3 id="iscomplete">isComplete</h3>

<pre><code class="language-c++">//Signature
bool isComplete() const
</code></pre>

<p>Return whether the motion profile has been followed start to finish and is done.</p>

<h3 id="reset">reset</h3>

<pre><code class="language-c++">//Signature
void reset()
</code></pre>

<p>Reset the controller so it can follow another profile.</p>

<h2 id="mpconsumerparams">MPConsumerParams</h2>

<p>The <code>MPConsumerParams</code> class encapsulates the parameters an <code>MPConsumer</code> takes.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
MPConsumerParams(const float ikV, const float ikA, const float ikP = 0)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikV</td>
<td>Feed-forward velocity gain</td>
</tr>

<tr>
<td>ikA</td>
<td>Feed-forward acceleration gain</td>
</tr>

<tr>
<td>ikP</td>
<td>Feedback proportional gain (default = 0)</td>
</tr>
</tbody>
</table>

<h2 id="mpcontroller">MPController</h2>

<p>The <code>MPController</code> class packages together an <code>MPConsumer</code> and an <code>MPGenerator</code> into one class which both generates and follows a motion profile.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
MPController(const MPGenParams&amp; igenParams, const MPConsumerParams&amp; iconParams)
MPController(const MPControllerParams&amp; iparams)

//Basic MPController construction
MPController foo(MPGenParams(1, 15, 1000), MPConsumerParams(6, 1.2, 0.5));
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>igenParams</td>
<td><code>MPGenParams</code></td>
</tr>

<tr>
<td>iconParams</td>
<td><code>MPConsumerParams</code></td>
</tr>

<tr>
<td>iparams</td>
<td><code>MPControllerParams</code></td>
</tr>
</tbody>
</table>

<h3 id="loop">loop</h3>

<pre><code class="language-c++">//Signature
virtual float loop(const float inewReading)
</code></pre>

<p>Loop the controller once over a new measurement and return the new response power.</p>

<h3 id="settarget">setTarget</h3>

<pre><code class="language-c++">//Signature
void setTarget(const int pos)
</code></pre>

<p>Set a new target for the controller, causing the internal motion profile to be regenerated.</p>

<h3 id="iscomplete">isComplete</h3>

<pre><code class="language-c++">//Signature
bool isComplete() const
</code></pre>

<p>Return whether the motion profile has been followed start to finish and is done.</p>

<h3 id="reset">reset</h3>

<pre><code class="language-c++">//Signature
void reset()
</code></pre>

<p>Reset the controller so it can follow another profile.</p>

<h2 id="mpcontrollerparams">MPControllerParams</h2>

<p>The <code>MPControllerParams</code> class encapsulates the parameters an <code>MPController</code> takes.</p>

<h3 id="constructor-1">Constructor</h3>

<pre><code class="language-c++">//Signature
MPControllerParams(const MPGenParams&amp; igenParams, const MPConsumerParams&amp; iconParams)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>igenParams</td>
<td><code>MPGenParams</code></td>
</tr>

<tr>
<td>iconParams</td>
<td><code>MPConsumerParams</code></td>
</tr>
</tbody>
</table>

<h2 id="mpgenerator">MPGenerator</h2>

<p>The <code>MPGenerator</code> class is a motion profile generator. It accepts position, velocity, and acceleration bounds and produces a motion profile within those bounds.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
MPGenerator(const float iaccel, const float imaxVel)
MPGenerator(const float iaccel, const float imaxVel, const float itargetPos)
MPGenerator(const float imaxAccel, const float iminAccel, const float imaxVel, const float itargetPos)
MPGenerator(const float imaxAccel, const float iminAccel, const float imaxVel, const float itargetPos, const float istartVel, const float iendVel)
MPGenerator(const MPGenParams&amp; iparams)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imaxAccel</td>
<td>Maximum acceleration</td>
</tr>

<tr>
<td>iminAccel</td>
<td>Minimum acceleration (i.e., maximum deceleration, make sure this value is negative)</td>
</tr>

<tr>
<td>imaxVel</td>
<td>Maximum velocity</td>
</tr>

<tr>
<td>itargetPos</td>
<td>Target position (how far should the robot travel)</td>
</tr>

<tr>
<td>istartVel</td>
<td>Starting velocity (normally 0)</td>
</tr>

<tr>
<td>iendVel</td>
<td>Ending velocity (normally 0)</td>
</tr>
</tbody>
</table>

<h3 id="generateprofile">generateProfile</h3>

<pre><code class="language-c++">//Signature
MotionProfile generateProfile(const float idt)
</code></pre>

<p>Generate and return a complete motion profile.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>idt</td>
<td>Timestep between targets</td>
</tr>
</tbody>
</table>

<h3 id="getnextveltarget">getNextVelTarget</h3>

<pre><code class="language-c++">//Signature
MPTarget getNextVelTarget(const float itime)
</code></pre>

<p>Calculate and return the next velocity target in the motion profile.</p>

<h3 id="iscomplete">isComplete</h3>

<pre><code class="language-c++">//Signature
bool isComplete() const
</code></pre>

<p>Return whether the motion profile has been followed start to finish and is done.</p>

<h2 id="mpgeneratorparams">MPGeneratorParams</h2>

<p>The <code>MPGeneratorParams</code> class encapsulates the parameters an <code>MPGenerator</code> takes.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
MPGenParams(const float imaxAccel, const float iminAccel, const float imaxVel, const float itargetPos, const float istartVel, const float iendVel)
MPGenParams(const float imaxAccel, const float iminAccel, const float imaxVel, const float itargetPos)
MPGenParams(const float iaccel, const float imaxVel, const float itargetPos)
MPGenParams(const float iaccel, const float imaxVel)
MPGenParams(const MPGenParams &amp;other)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imaxAccel</td>
<td>Maximum acceleration</td>
</tr>

<tr>
<td>iminAccel</td>
<td>Minimum acceleration (i.e., maximum deceleration, make sure this value is negative)</td>
</tr>

<tr>
<td>imaxVel</td>
<td>Maximum velocity</td>
</tr>

<tr>
<td>itargetPos</td>
<td>Target position (how far should the robot travel)</td>
</tr>

<tr>
<td>istartVel</td>
<td>Starting velocity (normally 0)</td>
</tr>

<tr>
<td>iendVel</td>
<td>Ending velocity (normally 0)</td>
</tr>
</tbody>
</table>

<h2 id="nspid">NsPid</h2>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
NsPid(const PidParams&amp; iparams, const VelMathParams&amp; ivelParams, const float iminVel, const float iscale = 0.1)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iparams</td>
<td><code>PidParams</code> to make the internal PID controller</td>
</tr>

<tr>
<td>ivelParams</td>
<td><code>VelMathParams</code> for the velocity calculations</td>
</tr>

<tr>
<td>iminVel</td>
<td>Minimum velocity at which the controller will start reducing the output power</td>
</tr>

<tr>
<td>iscale</td>
<td>Scale to reduce the output power by</td>
</tr>
</tbody>
</table>

<h3 id="loop">loop</h3>

<pre><code class="language-c++">//Signature
virtual float loop(const float inewReading) override
</code></pre>

<p>Do one iteration of Pid math to compute a new motor power. This needs to be called every so many milliseconds (15 ms works fine).</p>

<p>Calls <code>loop</code> from class <code>Pid</code>, and may return a reduced power if the velocity of the process is sufficiently low. The purpose of a low power mode is to prevent motors from stalling once they have reached their target (or if they can&rsquo;t quite reach their target).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>inewReading</td>
<td>New sensor reading</td>
</tr>
</tbody>
</table>

<h2 id="odomchassiscontroller-abstract">OdomChassisController (abstract)</h2>

<p>The <code>OdomChassisController</code> class inherits from <code>ChassisController</code>. It extends the <code>ChassisController</code> interface to add odometry-based functionality.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
OdomChassisController(OdomParams iparams)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iparams</td>
<td><code>OdomParams</code> (used to make a new <code>Odometry</code>)</td>
</tr>
</tbody>
</table>

<aside class="notice">
This class creates a new task inside its constructor and references a static class (Odometry). Be careful and remember to only make one.
</aside>

<h3 id="drivetopoint">driveToPoint</h3>

<pre><code class="language-c++">//Signature
virtual void driveToPoint(const float ix, const float iy, const bool ibackwards = false, const float ioffset = 0) = 0
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ix</td>
<td>X coordinate of destination</td>
</tr>

<tr>
<td>iy</td>
<td>Y coordinate of destination</td>
</tr>

<tr>
<td>ibackwards</td>
<td>Whether to drive to the destination backwards (default false)</td>
</tr>

<tr>
<td>ioffset</td>
<td>How far back from the destination to stop (default 0)</td>
</tr>
</tbody>
</table>

<p>Drive to the point (<code>ix</code>, <code>iy</code>) in the field frame. If required, the robot will first turn to face the destination point.</p>

<h3 id="turntoangle">turnToAngle</h3>

<pre><code class="language-c++">//Signature
virtual void turnToAngle(const float iangle) = 0
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iangle</td>
<td>Angle to face</td>
</tr>
</tbody>
</table>

<p>Turn to the angle <code>iangle</code> in the field frame.</p>

<h2 id="odomchassiscontrollermp">OdomChassisControllerMP</h2>

<p>The <code>OdomChassisControllerMP</code> class inherits from <code>OdomChassisController</code> and from <code>ChassisControllerMP</code>. It implements the <code>OdomChassisController</code> interface using motion profiling.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
OdomChassisControllerMP(const OdomParams&amp; params, const MPControllerParams&amp; iconparams)

//Make a new ChassisControllerMP using a skid steer model with two motors per side
OdomChassisControllerMP foo(
  OdomParams(
    SkidSteerModelParams&lt;2&gt;({1,3,2,4}, //The four motor ports
                            encoderInit(1,2,false), //Left encoder
                            encoderInit(3,4,true)), //Right encoder
    1.345,     //Distance scale (encoder ticks to mm)
    12.88361), //Turn scale (encoder ticks to deg)
  MPControllerParams(
    MPGenParams(1, 15, 1000),        //MPGenerator params; max &amp; min accel: 1, max vel: 15, target pos: 1000
    MPConsumerParams(6, 1.2, 0.5))); //MPConsumer params; kV: 6, kA: 1.2, kP: 0.5
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>params</td>
<td><code>OdomParams</code> (used to make a new <code>Odometry</code>)</td>
</tr>

<tr>
<td>igenParams</td>
<td><code>MPGenParams</code> (used to make a new <code>MPGenerator</code>)</td>
</tr>

<tr>
<td>icParams</td>
<td><code>MPConsumerParams</code> (used to make a new <code>MPConsumer</code>)</td>
</tr>
</tbody>
</table>

<h2 id="odomchassiscontrollerpid">OdomChassisControllerPid</h2>

<p>The <code>OdomChassisControllerPid</code> class inherits from <code>OdomChassisController</code> and from <code>ChassisControllerPid</code>. It implements the <code>OdomChassisController</code> interface using PID control.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
OdomChassisControllerPid(const OdomParams&amp; params, const PidParams&amp; idistanceParams, const PidParams&amp; iangleParams)

//Make a new OdomChassisControllerPid using a skid steer model with two motors per side
OdomChassisControllerPid foo(
  OdomParams(
    SkidSteerModelParams&lt;2&gt;({1,3,2,4}, //The four motor ports
                            encoderInit(1,2,false), //Left encoder
                            encoderInit(3,4,true)), //Right encoder
    1.345,     //Distance scale (encoder ticks to mm)
    12.88361), //Turn scale (encoder ticks to deg)
  PidParams(0,0,0),  //Distance PID controller
  PidParams(0,0,0)); //Angle PID controller
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>params</td>
<td><code>OdomParams</code> (used to make a new <code>Odometry</code>)</td>
</tr>

<tr>
<td>idistanceParams</td>
<td><code>PidParams</code> for the distance PID controller</td>
</tr>

<tr>
<td>iangleParams</td>
<td><code>PidParams</code> for the angle PID controller</td>
</tr>
</tbody>
</table>

<h2 id="odometry">Odometry</h2>

<p>The <code>Odometry</code> class tracks the robot as it moves, computing its position in the field frame. It is a singleton so its main method, <code>loop</code>, can be called in a task.</p>

<h3 id="setparams">setParams</h3>

<pre><code class="language-c++">//Signature
static void setParams(OdomParams&amp; iparams)
</code></pre>

<p>Set the model, scale, and turnScale parameters.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iparams</td>
<td><code>OdomParams</code></td>
</tr>
</tbody>
</table>

<h3 id="setscales">setScales</h3>

<pre><code class="language-c++">//Signature
static void setScales(const float iscale, const float iturnScale)
</code></pre>

<p>Set the scale and turnScale parameters.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iscale</td>
<td>Driving scale (encoder ticks to mm)</td>
</tr>

<tr>
<td>iturnScale</td>
<td>Turning scale (encoder ticks to degrees)</td>
</tr>
</tbody>
</table>

<h3 id="guessscales">guessScales</h3>

<pre><code class="language-c++">//Signature
static void guessScales(const float chassisDiam, const float wheelDiam, const float ticksPerRev = 360.0)
</code></pre>

<p>Attempt to guess the two odometry scales from chassis and wheel diameter. This might get you close, but it serves only as a quick and temporary fix. The two odometry scales must be found experimentally for your specific robot.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>chassisDiam</td>
<td>Center-to-center wheel base in inches</td>
</tr>

<tr>
<td>wheelDiam</td>
<td>Edge-to-edge wheel diameter in inches</td>
</tr>

<tr>
<td>ticksPerRev</td>
<td>Quadrate encoder ticks per one wheel revolution (default 360)</td>
</tr>
</tbody>
</table>

<h3 id="loop">loop</h3>

<pre><code class="language-c++">//Signature
static OdomState loop()
</code></pre>

<p>Do one iteration of odometry math to compute the new position of the robot. This needs to be called every so many milliseconds (15 ms seems to work fine).</p>

<h3 id="getstate">getState</h3>

<pre><code class="language-c++">//Signature
static OdomState getState()
</code></pre>

<p>Return the last calculated position of the robot.</p>

<h2 id="odomparams">OdomParams</h2>

<p>The <code>OdomParams</code> class encapsulates the parameters an <code>Odometry</code> takes.</p>

<table>
<thead>
<tr>
<th>Member</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>model</td>
<td><code>ChassisModel</code></td>
</tr>

<tr>
<td>scale</td>
<td>Driving scale (encoder ticks to mm)</td>
</tr>

<tr>
<td>turnScale</td>
<td>Turning scale (encoder ticks to degrees)</td>
</tr>
</tbody>
</table>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
OdomParams(const ChassisModelParams&amp; iparams, const float iscale, const float iturnScale)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iparams</td>
<td><code>ChassisModelParams</code> (used to make a new <code>ChassisModel</code>)</td>
</tr>

<tr>
<td>iscale</td>
<td>Driving scale (encoder ticks to mm)</td>
</tr>

<tr>
<td>iturnScale</td>
<td>Turning scale (encoder ticks to degrees)</td>
</tr>
</tbody>
</table>

<h2 id="odomstate">OdomState</h2>

<p>The <code>OdomState</code> class is a simple container for the position of the robot tracked by <code>Odometry</code>.</p>

<table>
<thead>
<tr>
<th>Member</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>x</td>
<td>X coordinate of robot</td>
</tr>

<tr>
<td>y</td>
<td>Y coordinate of robot</td>
</tr>

<tr>
<td>theta</td>
<td>Theta of robot</td>
</tr>
</tbody>
</table>

<h3 id="constructor-1">Constructor</h3>

<pre><code class="language-c++">//Signature
OdomState(const float ix, const float iy, const float itheta)
OdomState()
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ix</td>
<td>X coordinate of robot</td>
</tr>

<tr>
<td>iy</td>
<td>Y coordinate of robot</td>
</tr>

<tr>
<td>itheta</td>
<td>Theta of robot</td>
</tr>
</tbody>
</table>

<h2 id="odommath">OdomMath</h2>

<p>The <code>OdomMath</code> class provides static implementations for common odometry operations.</p>

<h3 id="computedistancetopoint">computeDistanceToPoint</h3>

<pre><code class="language-c++">//Signature
static float computeDistanceToPoint(const float ix, const float iy, const OdomState&amp; istate)
</code></pre>

<p>Calculate the distance from the robot to a point, (<code>ix</code>, <code>iy</code>).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ix</td>
<td>X coordinate</td>
</tr>

<tr>
<td>iy</td>
<td>Y coordinate</td>
</tr>

<tr>
<td>istate</td>
<td>Odometry state</td>
</tr>
</tbody>
</table>

<h3 id="computeangletopoint">computeAngleToPoint</h3>

<pre><code class="language-c++">//Signature
static float computeAngleToPoint(const float ix, const float iy, const OdomState&amp; istate)
</code></pre>

<p>Calculate the angle from the robot to a point, (<code>ix</code>, <code>iy</code>).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ix</td>
<td>X coordinate</td>
</tr>

<tr>
<td>iy</td>
<td>Y coordinate</td>
</tr>

<tr>
<td>istate</td>
<td>Odometry state</td>
</tr>
</tbody>
</table>

<h3 id="computedistanceandangletopoint">computeDistanceAndAngleToPoint</h3>

<pre><code class="language-c++">//Signature
static DistanceAndAngle computeDistanceAndAngleToPoint(const float ix, const float iy, const OdomState&amp; istate)
</code></pre>

<p>Calculate the distance and the angle from the robot to a point, (<code>ix</code>, <code>iy</code>).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ix</td>
<td>X coordinate</td>
</tr>

<tr>
<td>iy</td>
<td>Y coordinate</td>
</tr>

<tr>
<td>istate</td>
<td>Odometry state</td>
</tr>
</tbody>
</table>

<h2 id="pid">Pid</h2>

<p>The <code>Pid</code> class implements the Pid algorithm, with some quality-of-life changes to support online tuning.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
Pid(const float ikP, const float ikI, const float ikD, const float ikBias = 0)
Pid(const PidParams&amp; params)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>ikI</td>
<td>Integral gain</td>
</tr>

<tr>
<td>ikD</td>
<td>Derivative gain</td>
</tr>

<tr>
<td>ikBias</td>
<td>Controller bias (this value added to output, default 0)</td>
</tr>

<tr>
<td>params</td>
<td><code>PidParams</code></td>
</tr>
</tbody>
</table>

<h3 id="loop">loop</h3>

<pre><code class="language-c++">//Signature
virtual float loop(const float inewReading)
</code></pre>

<p>Do one iteration of Pid math to compute a new motor power. This needs to be called every so many milliseconds (15 ms works fine).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>inewReading</td>
<td>New sensor reading</td>
</tr>
</tbody>
</table>

<h3 id="setgains">setGains</h3>

<pre><code class="language-c++">//Signature
void setGains(const float ikP, const float ikI, const float ikD, const float ikBias = 0)
</code></pre>

<p>Set new controller gains and bias.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>ikI</td>
<td>Integral gain</td>
</tr>

<tr>
<td>ikD</td>
<td>Derivative gain</td>
</tr>

<tr>
<td>ikBias</td>
<td>Controller bias (this value added to output, default 0)</td>
</tr>
</tbody>
</table>

<h3 id="setsampletime">setSampleTime</h3>

<pre><code class="language-c++">//Signature
void setSampleTime(const int isampleTime)
</code></pre>

<p>Set the timestep (in ms) between calls to <code>loop</code>.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>isampleTime</td>
<td>Timestep between calls to <code>loop</code> in ms</td>
</tr>
</tbody>
</table>

<h3 id="setoutputlimits">setOutputLimits</h3>

<pre><code class="language-c++">//Signature
void setOutputLimits(float imax, float imin)
</code></pre>

<p>Set the max and min value for the controller output.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imax</td>
<td>Max output</td>
</tr>

<tr>
<td>imin</td>
<td>Min output</td>
</tr>
</tbody>
</table>

<h3 id="setintegrallimits">setIntegralLimits</h3>

<pre><code class="language-c++">//Signature
void setIntegralLimits(float imax, float imin)
</code></pre>

<p>Set the max and min value for the integrator sum.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imax</td>
<td>Max integrator value</td>
</tr>

<tr>
<td>imin</td>
<td>Min integrator value</td>
</tr>
</tbody>
</table>

<h3 id="reset">reset</h3>

<pre><code class="language-c++">//Signature
void reset()
</code></pre>

<p>Reset the controller so it will start from zero again.</p>

<h3 id="setintegratorreset">setIntegratorReset</h3>

<pre><code class="language-c++">//Signature
void setIntegratorReset(bool iresetOnZero)
</code></pre>

<p>Set whether the integrator should be cleared when the controller&rsquo;s error is zero or changes sign.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iresetOnZero</td>
<td>Whether the integrator should be cleared when the controller&rsquo;s error is zero or changes sign</td>
</tr>
</tbody>
</table>

<h3 id="flipdisable">flipDisable</h3>

<pre><code class="language-c++">//Signature
void flipDisable()
</code></pre>

<p>Change whether the controller is on or off. A controller which is off will output 0.</p>

<h3 id="settarget">setTarget</h3>

<pre><code class="language-c++">//Signature
void setTarget(const float itarget)
</code></pre>

<p>Set the target value.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>itarget</td>
<td>New target value</td>
</tr>
</tbody>
</table>

<h3 id="getoutput">getOutput</h3>

<pre><code class="language-c++">//Signature
float getOutput() const
</code></pre>

<p>Return the most recent controller output.</p>

<h2 id="pidparams">PidParams</h2>

<p>The <code>PidParams</code> class encapsulates the parameters a <code>Pid</code> takes.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>kP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>kI</td>
<td>Integral gain</td>
</tr>

<tr>
<td>kD</td>
<td>Derivative gain</td>
</tr>

<tr>
<td>kBias</td>
<td>Controller bias (this value added to output)</td>
</tr>
</tbody>
</table>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
PidParams(const float ikP, const float ikI, const float ikD, const float ikBias = 0)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>ikI</td>
<td>Integral gain</td>
</tr>

<tr>
<td>ikD</td>
<td>Derivative gain</td>
</tr>

<tr>
<td>ikBias</td>
<td>Controller bias (this value added to output, default 0)</td>
</tr>
</tbody>
</table>

<h2 id="potentiometer">Potentiometer</h2>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
explicit constexpr Potentiometer()
explicit constexpr Potentiometer(const unsigned long long int iport)
explicit constexpr Potentiometer(const unsigned long long int iport, const bool iinverted)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iport</td>
<td>Analog input port</td>
</tr>

<tr>
<td>iinverted</td>
<td>Whether the potentiometer is inverted (range is 0-&gt;4095 or 4095-&gt;0)</td>
</tr>
</tbody>
</table>

<p>This class also has literals available:</p>

<table>
<thead>
<tr>
<th>Literal</th>
<th>Potentiometer Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>n_p</code></td>
<td><code>Potentiometer(n, false)</code></td>
</tr>

<tr>
<td><code>n_ip</code></td>
<td><code>Potentiometer(n, true)</code></td>
</tr>
</tbody>
</table>

<h3 id="get">get</h3>

<pre><code class="language-c++">//Signature
int get() const
</code></pre>

<p>Return the value of this potentiometer.</p>

<h2 id="quadencoder">QuadEncoder</h2>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
QuadEncoder(const unsigned char iportTop, const unsigned char iportBottom)
QuadEncoder(const unsigned char iportTop, const unsigned char iportBottom, const bool ireversed)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iportTop</td>
<td>Top digital in port</td>
</tr>

<tr>
<td>iportBototm</td>
<td>Bottom digital in port</td>
</tr>

<tr>
<td>ireversed</td>
<td>Whether the encoder is reversed or not (clockwise turn increases vs. decreases ticks)</td>
</tr>
</tbody>
</table>

<h3 id="get">get</h3>

<pre><code class="language-c++">//Signature
int get() const
</code></pre>

<p>Return the current tick count.</p>

<h3 id="reset">reset</h3>

<pre><code class="language-c++">//Signature
void reset() const
</code></pre>

<p>Reset the tick count to zero.</p>

<h2 id="rangefinder">RangeFinder</h2>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
RangeFinder(const unsigned char iportTop, const unsigned char iportBottom)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iportTop</td>
<td>Top digital port</td>
</tr>

<tr>
<td>iportBottom</td>
<td>Bottom digital port</td>
</tr>
</tbody>
</table>

<h3 id="get">get</h3>

<pre><code class="language-c++">//Signature
int get() const
</code></pre>

<p>Return the current measured range in centimeters.</p>

<h2 id="timer">Timer</h2>

<p>The <code>Timer</code> class has timing-related utilities to make measuring time differences and writing non-blocking code in loops easier.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
Timer()
</code></pre>

<p>The constructor does not take any parameters.</p>

<h3 id="getdt">getDt</h3>

<pre><code class="language-c++">//Signature
unsigned long getDt()
</code></pre>

<p>Return the time passed in ms since the last time this function was called.</p>

<h3 id="getstartingtime">getStartingTime</h3>

<pre><code class="language-c++">//Signature
unsigned long getStartingTime() const
</code></pre>

<p>Return the time in ms the timer was constructed.</p>

<h3 id="getdtfromstart">getDtFromStart</h3>

<pre><code class="language-c++">//Signature
unsigned long getDtFromStart() const
</code></pre>

<p>Return the time passed in ms since the timer was constructed.</p>

<h3 id="placemark">placeMark</h3>

<pre><code class="language-c++">//Signature
void placeMark()
</code></pre>

<p>Place a time marker. Placing another marker will overwrite the previous one.</p>

<h3 id="placehardmark">placeHardMark</h3>

<pre><code class="language-c++">//Signature
void placeHardMark()
</code></pre>

<p>Place a hard time marker. Placing another hard marker will not overwrite the previous one; instead, <code>clearHardMark()</code> must be called before another can be placed.</p>

<h3 id="clearhardmark">clearHardMark</h3>

<pre><code class="language-c++">//Signature
unsigned long clearHardMark()
</code></pre>

<p>Clear and return the current hard marker.</p>

<h3 id="getdtfrommark">getDtFromMark</h3>

<pre><code class="language-c++">//Signature
unsigned long getDtFromMark()
</code></pre>

<p>Return the time in ms since the marker was placed.</p>

<h3 id="getdtfromhardmark">getDtFromHardMark</h3>

<pre><code class="language-c++">//Signature
unsigned long getDtFromHardMark()
</code></pre>

<p>Return the time in ms since the hard marker was placed.</p>

<h3 id="repeat">repeat</h3>

<pre><code class="language-c++">//Signature
bool repeat(unsigned long ms)
</code></pre>

<p>Return true when the input time period <code>ms</code> has passed, and then reset. Meant to be used in loops to execute a block of code every so many ms without blocking the loop.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ms</td>
<td>Number of milliseconds between calls of <code>repeat</code> that return true</td>
</tr>
</tbody>
</table>

<h2 id="velmath">VelMath</h2>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
VelMath(const float iticksPerRev, const float ialpha = 0.19, const float ibeta = 0.041)
VelMath(const VelMathParams&amp; iparams)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iticksPerRev</td>
<td>Encoder ticks per one revolution</td>
</tr>

<tr>
<td>ialpha</td>
<td><code>DemaFilter</code> alpha gain</td>
</tr>

<tr>
<td>ibeta</td>
<td><code>DemaFilter</code> beta gain</td>
</tr>
</tbody>
</table>

<h3 id="loop">loop</h3>

<pre><code class="language-c++">//Signature
float loop(const float inewPos)
</code></pre>

<p>Calculate, filter, and return a new velocity. This need to be called every so many milliseconds (not any faster than 15 ms).</p>

<h3 id="setgains">setGains</h3>

<pre><code class="language-c++">//Signature
void setGains(const float ialpha, const float ibeta)
</code></pre>

<p>Set new filter gains.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ialpha</td>
<td>Alpha gain</td>
</tr>

<tr>
<td>ibeta</td>
<td>Beta gain</td>
</tr>
</tbody>
</table>

<h3 id="setticksperrev">setTicksPerRev</h3>

<pre><code class="language-c++">//Signature
void setTicksPerRev(const float iTPR)
</code></pre>

<p>Set a new ticks per rev value.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iTPR</td>
<td>Encoder ticks per one revolution</td>
</tr>
</tbody>
</table>

<h3 id="getoutput">getOutput</h3>

<pre><code class="language-c++">//Signature
float getOutput() const
</code></pre>

<p>Return the most recent velocity.</p>

<h3 id="getdiff">getDiff</h3>

<pre><code class="language-c++">//Signature
float getDiff() const
</code></pre>

<p>Return the difference between the last and second to last velocity. Dividing this value by the sample time would give an acceleration.</p>

<h2 id="velpid">VelPid</h2>

<p>The <code>VelPid</code> class implements the Pid algorithm for the velocity domain, with some quality-of-life changes to support online tuning.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
VelPid(const float ikP, const float ikD)
VelPid(const VelPidParams&amp; params)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>ikI</td>
<td>Integral gain</td>
</tr>

<tr>
<td>ikD</td>
<td>Derivative gain</td>
</tr>

<tr>
<td>ikBias</td>
<td>Controller bias (this value added to output, default 0)</td>
</tr>

<tr>
<td>params</td>
<td><code>VelPidParams</code></td>
</tr>
</tbody>
</table>

<h3 id="loopvel">loopVel</h3>

<pre><code class="language-c++">//Signature
virtual float loopVel(const float inewReading)
</code></pre>

<p>Do one iteration of velocity math to compute a new filtered velocity. This is only meant to be used separately from <code>loop</code> if you only want to compute a new velocity. Don&rsquo;t call loopVel if you are already calling loop because loop will call loopVel on its own.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>inewReading</td>
<td>New sensor reading</td>
</tr>
</tbody>
</table>

<h3 id="loop">loop</h3>

<pre><code class="language-c++">//Signature
virtual float loop(const float inewReading)
</code></pre>

<p>Do one iteration of Pid math to compute a new motor power. This needs to be called every so many milliseconds (15 ms works fine).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>inewReading</td>
<td>New sensor reading</td>
</tr>
</tbody>
</table>

<h3 id="setgains">setGains</h3>

<pre><code class="language-c++">//Signature
void setGains(const float ikP, const float ikD)
</code></pre>

<p>Set new controller gains and bias.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>ikD</td>
<td>Derivative gain</td>
</tr>
</tbody>
</table>

<h3 id="setfiltergains">setFilterGains</h3>

<pre><code class="language-c++">//Signature
void setFilterGains(const float alpha, const float beta)
</code></pre>

<p>Set new gains for the <code>DemaFilter</code></p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>alpha</td>
<td>Alpha gain</td>
</tr>

<tr>
<td>beta</td>
<td>Beta gain</td>
</tr>
</tbody>
</table>

<h3 id="setsampletime">setSampleTime</h3>

<pre><code class="language-c++">//Signature
void setSampleTime(const int isampleTime)
</code></pre>

<p>Set the timestep (in ms) between calls to <code>loop</code>.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>isampleTime</td>
<td>Timestep between calls to <code>loop</code> in ms</td>
</tr>
</tbody>
</table>

<h3 id="setticksperrev">setTicksPerRev</h3>

<pre><code class="language-c++">//Signature
void setTicksPerRev(const float tpr)
</code></pre>

<p>Set the number of measurement units per revolution. Default is 360 (quadrature encoder).</p>

<h3 id="setoutputlimits">setOutputLimits</h3>

<pre><code class="language-c++">//Signature
void setOutputLimits(float imax, float imin)
</code></pre>

<p>Set the max and min value for the controller output.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imax</td>
<td>Max output</td>
</tr>

<tr>
<td>imin</td>
<td>Min output</td>
</tr>
</tbody>
</table>

<h3 id="reset">reset</h3>

<pre><code class="language-c++">//Signature
void reset()
</code></pre>

<p>Reset the controller so it will start from zero again.</p>

<h3 id="flipdisable">flipDisable</h3>

<pre><code class="language-c++">//Signature
void flipDisable()
</code></pre>

<p>Change whether the controller is on or off. A controller which is off will output 0.</p>

<h3 id="settarget">setTarget</h3>

<pre><code class="language-c++">//Signature
void setTarget(const float itarget)
</code></pre>

<p>Set the target value.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>itarget</td>
<td>New target value</td>
</tr>
</tbody>
</table>

<h3 id="getoutput">getOutput</h3>

<pre><code class="language-c++">//Signature
float getOutput() const
</code></pre>

<p>Return the most recent controller output.</p>

<h2 id="velpidparams">VelPidParams</h2>

<p>The <code>VelPidParams</code> class encapsulates the parameters a <code>VelPid</code> takes.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>kP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>kD</td>
<td>Derivative gain</td>
</tr>
</tbody>
</table>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
VelPidParams(const float ikP, const float ikD)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>ikD</td>
<td>Derivative gain</td>
</tr>
</tbody>
</table>
</p>


			<aside class="copyright" role="note">
				
				Documentation built with
				<a href="https://www.gohugo.io" target="_blank">Hugo</a>
				using the
				<a href="http://github.com/digitalcraftsman/hugo-material-docs" target="_blank">Material</a> theme.
			</aside>

			<footer class="footer">
				

<nav class="pagination" aria-label="Footer">
  <div class="previous">
  
      <a href="https://okapilib.github.io/OkapiLib/tutorials/pidtutorial/" title="">
        <span class="direction">
          Previous
        </span>
        <div class="page">
          <div class="button button-previous" role="button" aria-label="Previous">
            <i class="icon icon-back"></i>
          </div>
          <div class="stretch">
            <div class="title">
              
            </div>
          </div>
        </div>
      </a>
  
  </div>

  <div class="next">
  
      <a href="https://okapilib.github.io/OkapiLib/getting-started/" title="Getting Started">
        <span class="direction">
          Next
        </span>
        <div class="page">
          <div class="stretch">
            <div class="title">
              Getting Started
            </div>
          </div>
          <div class="button button-next" role="button" aria-label="Next">
            <i class="icon icon-forward"></i>
          </div>
        </div>
      </a>
  
  </div>
</nav>





			</footer>
		</div>
	</article>

	<div class="results" role="status" aria-live="polite">
		<div class="scrollable">
			<div class="wrapper">
				<div class="meta"></div>
				<div class="list"></div>
			</div>
		</div>
	</div>
</main>

    <script>
    
      var base_url = 'https:\/\/okapilib.github.io\/OkapiLib\/';
      var repo_id  = 'OkapiLib\/OkapiLib';
    
    </script>

    <script src="https://okapilib.github.io/OkapiLib/javascripts/application.js"></script>
    

    <script>
      /* Add headers to scrollspy */
      var headers   = document.getElementsByTagName("h2");
      var scrollspy = document.getElementById('scrollspy');

      if(scrollspy) {
        if(headers.length > 0) {
          for(var i = 0; i < headers.length; i++) {
            var li = document.createElement("li");
            li.setAttribute("class", "anchor");

            var a  = document.createElement("a");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", headers[i].innerHTML);
            a.innerHTML = headers[i].innerHTML;

            li.appendChild(a)
            scrollspy.appendChild(li);
          }
        } else {
          scrollspy.parentElement.removeChild(scrollspy)
        }


        /* Add permanent link next to the headers */
        var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

        for(var i = 0; i < headers.length; i++) {
            var a = document.createElement("a");
            a.setAttribute("class", "headerlink");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", "Permanent link")
            a.innerHTML = "#";
            headers[i].appendChild(a);
        }
      }
    </script>

    
      <script>
        (function(i,s,o,g,r,a,m){
          i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||
          []).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;
          m.parentNode.insertBefore(a,m)
        })(window, document,
          'script', '//www.google-analytics.com/analytics.js', 'ga');
         
        ga('create', 'UA-108357936-1', 'auto');
        ga('set', 'anonymizeIp', true);
        ga('send', 'pageview');
         
        var buttons = document.querySelectorAll('a');
        Array.prototype.map.call(buttons, function(item) {
          if (item.host != document.location.host) {
            item.addEventListener('click', function() {
              var action = item.getAttribute('data-action') || 'follow';
              ga('send', 'event', 'outbound', action, item.href);
            });
          }
        });
         
        var query = document.querySelector('.query');
        query.addEventListener('blur', function() {
          if (this.value) {
            var path = document.location.pathname;
            ga('send', 'pageview', path + '?q=' + this.value);
          }
        });
      </script>
    

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

